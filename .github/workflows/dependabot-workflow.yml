name: Reusable Dependabot Workflow

# Documentación del Workflow
# =========================
# Este workflow permite automatizar la gestión de dependencias utilizando Dependabot.
# Características principales:
# - Configurable para diferentes ecosistemas (npm, pip, maven, etc.)
# - Puede ejecutarse bajo demanda o con programación
# - Configurable para auto-aprobar y auto-fusionar actualizaciones
# - Simple y directo para integrarse en pipelines de CI/CD

on:
  workflow_call:
    inputs:
      # Parámetros de configuración general
      package_ecosystem:
        required: true
        type: string
        description: 'Ecosistema de paquetes (npm, pip, maven, docker, etc.)'
      directory:
        required: true
        type: string
        description: 'Directorio donde se encuentra el archivo de dependencias'
      dependency_file_path:
        required: false
        type: string
        default: ''
        description: 'Ruta exacta del archivo de dependencias relativa al repositorio. Si se omite, se detecta automáticamente para ecosistemas conocidos'
      schedule_interval:
        required: false
        type: string
        default: ''
        description: 'Frecuencia de verificación (daily, weekly, monthly). Si está vacío, se ejecuta bajo demanda'
      open_pull_requests_limit:
        required: false
        type: number
        default: 10
        description: 'Límite de PRs abiertos simultáneamente'
      
      # Parámetros para auto-aprobación y auto-fusión
      auto_approve:
        required: false
        type: boolean
        default: false
        description: 'Aprobar automáticamente PRs de Dependabot'
      auto_merge:
        required: false
        type: boolean
        default: false
        description: 'Fusionar automáticamente PRs de Dependabot'
      auto_merge_label:
        required: false
        type: string
        default: 'dependencies'
        description: 'Etiqueta que deben tener los PRs de Dependabot para ser auto-fusionados. Dejar vacío para no filtrar por etiqueta'
      
      # Parámetros para configuración de versiones
      allow_major_versions:
        required: false
        type: boolean
        default: false
        description: 'Permitir actualizaciones de versiones mayores'

jobs:
  check-dependencies:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Setup Dependabot configuration
        id: setup_dependabot_config
        env:
          PACKAGE_ECOSYSTEM: ${{ inputs.package_ecosystem }}
          DIRECTORY: ${{ inputs.directory }}
          SCHEDULE_INTERVAL: ${{ inputs.schedule_interval }}
          OPEN_PULL_REQUESTS_LIMIT: ${{ inputs.open_pull_requests_limit }}
          ALLOW_MAJOR_VERSIONS: ${{ inputs.allow_major_versions }}
          TARGET_BRANCH: ${{ github.event.repository.default_branch || github.ref_name }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          DEPENDENCY_FILE_OVERRIDE: ${{ inputs.dependency_file_path }}
        run: |
          set -euo pipefail
          mkdir -p .github

          config_error=""
          if [ -z "${SCHEDULE_INTERVAL}" ]; then
            echo "Se omitió la configuración de dependabot.yml para ejecuciones bajo demanda" >> "$GITHUB_STEP_SUMMARY"
            echo "config_written=false" >> "$GITHUB_OUTPUT"
            echo "config_entry=" >> "$GITHUB_OUTPUT"
            echo "config_error=" >> "$GITHUB_OUTPUT"
          else
            log_file="$RUNNER_TEMP/dependabot_setup.log"
            : > "$log_file"

            set +e
python <<'PY' >"$log_file" 2>&1
            import base64
            import json
            import os
            import subprocess
            import sys
            import time

            try:
              import yaml  # type: ignore
            except ImportError:  # pragma: no cover
              subprocess.check_call([sys.executable, "-m", "pip", "install", "--quiet", "PyYAML"])
              import yaml  # type: ignore

            repo = os.environ["GITHUB_REPOSITORY"]
            branch = os.environ.get("TARGET_BRANCH") or "main"
            ecosystem = os.environ["PACKAGE_ECOSYSTEM"]
            directory = os.environ["DIRECTORY"]
            interval = os.environ["SCHEDULE_INTERVAL"]
            pr_limit = int(os.environ["OPEN_PULL_REQUESTS_LIMIT"])
            allow_major = os.environ["ALLOW_MAJOR_VERSIONS"].lower() == "true"

            def gh_api(args, body=None):
              return subprocess.run(["gh", "api", *args], input=body, text=True, capture_output=True)

            def load_config():
              result = gh_api([
                "-H", "Accept: application/vnd.github+json",
                f"/repos/{repo}/contents/.github/dependabot.yml?ref={branch}"
              ])

              if result.returncode == 0:
                data = json.loads(result.stdout)
                sha = data["sha"]
                content = base64.b64decode(data["content"]).decode("utf-8")
                config = yaml.safe_load(content) or {}
              else:
                stderr = result.stderr or ""
                if "404" in stderr:
                  sha = None
                  config = {}
                else:
                  sys.stderr.write(stderr)
                  sys.exit(result.returncode)

              config.setdefault("version", 2)
              config.setdefault("updates", [])
              return sha, config

            def build_update():
              update = {
                "package-ecosystem": ecosystem,
                "directory": directory,
                "schedule": {"interval": interval},
                "open-pull-requests-limit": pr_limit,
              }

              if not allow_major:
                update["ignore"] = [{
                  "dependency-name": "*",
                  "update-types": ["version-update:semver-major"],
                }]

              return update

            update_entry = build_update()

            for attempt in range(1, 6):
              sha, config = load_config()
              updates = config.get("updates", [])
              updates = [u for u in updates if not (
                u.get("package-ecosystem") == update_entry["package-ecosystem"]
                and u.get("directory") == update_entry["directory"]
              )]
              updates.append(update_entry)
              updates.sort(key=lambda u: (u.get("package-ecosystem", ""), u.get("directory", "")))
              config["updates"] = updates

              new_content = yaml.safe_dump(config, sort_keys=False)
              payload = {
                "message": f"chore: Configure Dependabot for {ecosystem} {directory}",
                "content": base64.b64encode(new_content.encode()).decode(),
                "branch": branch,
              }
              if sha:
                payload["sha"] = sha

              result = gh_api([
                "-X", "PUT",
                f"/repos/{repo}/contents/.github/dependabot.yml",
                "--input", "-",
              ], json.dumps(payload))

              if result.returncode == 0:
                break

              stderr = result.stderr or ""
              if "409" in stderr and attempt < 5:
                time.sleep(2)
                continue

              sys.stderr.write(stderr)
              sys.exit(result.returncode)
            else:
              sys.stderr.write("No se pudo actualizar dependabot.yml después de varios intentos\n")
              sys.exit(1)
PY
            status=$?
            set -e
            if [ $status -ne 0 ]; then
              config_error="No se pudo actualizar .github/dependabot.yml"
              if [ -s "$log_file" ]; then
                echo "--- Registro de error de dependabot.yml ---" >&2
                cat "$log_file" >&2
                echo "--- Fin del registro ---" >&2
                config_error="$(tail -n 10 "$log_file" | sed 's/|/-/g' | tr '\n' ' ' | sed 's/  */ /g')"
              fi
              echo "config_written=false" >> "$GITHUB_OUTPUT"
              echo "config_entry=${PACKAGE_ECOSYSTEM}:${DIRECTORY}" >> "$GITHUB_OUTPUT"
              echo "config_error=$config_error" >> "$GITHUB_OUTPUT"
              exit $status
            fi

            echo "config_written=true" >> "$GITHUB_OUTPUT"
            echo "config_entry=${PACKAGE_ECOSYSTEM}:${DIRECTORY}" >> "$GITHUB_OUTPUT"
            echo "config_error=$config_error" >> "$GITHUB_OUTPUT"
          fi

          manifest="$DEPENDENCY_FILE_OVERRIDE"
          if [ -z "$manifest" ]; then
            case "$PACKAGE_ECOSYSTEM" in
              npm|yarn|pnpm)
                manifest="package.json"
                ;;
              pip)
                manifest="requirements.txt"
                ;;
              poetry)
                manifest="pyproject.toml"
                ;;
              maven)
                manifest="pom.xml"
                ;;
              gradle)
                manifest="build.gradle"
                ;;
              gradle-kotlin)
                manifest="build.gradle.kts"
                ;;
              cargo)
                manifest="Cargo.toml"
                ;;
              composer)
                manifest="composer.json"
                ;;
              gomod)
                manifest="go.mod"
                ;;
              bundler)
                manifest="Gemfile"
                ;;
              docker)
                manifest="Dockerfile"
                ;;
              github-actions)
                manifest=".github/workflows"
                ;;
              *)
                echo "No se pudo determinar el archivo de dependencias para el ecosistema '$PACKAGE_ECOSYSTEM'." >&2
                echo "Proporciona 'dependency_file_path' al invocar el workflow." >&2
                exit 1
                ;;
            esac
          fi

          dir="$DIRECTORY"
          if [ "$dir" = "/" ]; then
            dir=""
          else
            dir="${dir#/}"
            dir="${dir%/}"
          fi

          if [ -n "$dir" ]; then
            dependency_path="$dir/$manifest"
          else
            dependency_path="$manifest"
          fi

          echo "Archivo de dependencias resuelto: $dependency_path" >> "$GITHUB_STEP_SUMMARY"
          echo "dependency_file=$dependency_path" >> "$GITHUB_OUTPUT"
          echo "DEPENDENCY_FILE=$dependency_path" >> "$GITHUB_ENV"
      
      # Si no hay schedule_interval, ejecutar verificación inmediata
      - name: Run immediate dependency check
        if: ${{ inputs.schedule_interval == '' }}
        run: |
          echo "Ejecutando verificación inmediata de dependencias"
          # Usar GitHub CLI para verificar dependencias
          gh api -X POST /repos/${{ github.repository }}/dependabot/scans \
            -f dependency-file-path="$DEPENDENCY_FILE" \
            -f package-ecosystem="${{ inputs.package_ecosystem }}"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Resumen del workflow
        if: ${{ always() }}
        env:
          JOB_STATUS: ${{ job.status }}
          INPUT_SCHEDULE_INTERVAL: ${{ inputs.schedule_interval }}
          INPUT_PACKAGE_ECOSYSTEM: ${{ inputs.package_ecosystem }}
          INPUT_DIRECTORY: ${{ inputs.directory }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CONFIG_WRITTEN: ${{ steps.setup_dependabot_config.outputs.config_written }}
          CONFIG_ENTRY: ${{ steps.setup_dependabot_config.outputs.config_entry }}
          CONFIG_ERROR: ${{ steps.setup_dependabot_config.outputs.config_error }}
        run: |
          set -euo pipefail

          status_icon="✅"
          status_text="Ejecución completada"

          if [ "${JOB_STATUS}" != "success" ]; then
            status_icon="❌"
            status_text="Ejecución con errores"
          fi

          dependency_file="${DEPENDENCY_FILE:-No determinado}"

          if [ "${CONFIG_WRITTEN}" = "true" ]; then
            mode="Programado (configuración escrita)"
            archivo=".github/dependabot.yml (${CONFIG_ENTRY:-entrada registrada})"
          else
            mode="Bajo demanda (escaneo inmediato)"
            archivo="$dependency_file"
          fi

          {
            echo "## 🚀 Resumen de Dependabot"
            echo ""
            echo "| 🧩 Clave | Valor |"
            echo "| --- | --- |"
            echo "| Repositorio | \`${GITHUB_REPOSITORY}\` |"
            echo "| Directorio | \`${INPUT_DIRECTORY}\` |"
            echo "| Ecosistema | \`${INPUT_PACKAGE_ECOSYSTEM}\` |"
            echo "| Estado | ${status_icon} ${status_text} |"
            echo "| Modo | ${mode} |"
            echo "| Archivo evaluado | \`${archivo}\` |"
          } >> "$GITHUB_STEP_SUMMARY"

          pr_table=$(gh pr list --repo "$GITHUB_REPOSITORY" --state open --search "author:app/dependabot" --limit 20 --json number,title,url,baseRefName --jq '
            if length == 0 then
              ""
            else
              (["| Número | Título | Rama base | URL |","| --- | --- | --- | --- |"] +
                (map("| #" + (.number|tostring) + " | " + (.title|gsub("\\|";"\\|")) + " | " + .baseRefName + " | " + .url + " |")))
                | join("\n")
            end' )

          {
            echo ""
            if [ -z "$pr_table" ]; then
              echo "_No se encontraron PRs abiertos de Dependabot en este momento._"
            else
              echo "### 📬 PRs abiertos de Dependabot"
              echo ""
              echo "$pr_table"
            fi

            if [ "${JOB_STATUS}" != "success" ]; then
              echo ""
              echo "❗ **Error:** ${CONFIG_ERROR:-Revisa los logs de los pasos anteriores para más detalles.}"
            elif [ "${CONFIG_WRITTEN}" = "true" ]; then
              echo ""
              echo "ℹ️ Dependabot generará PRs cuando procese esta configuración (según el intervalo definido)."
            else
              echo ""
              echo "✅ Se solicitó un escaneo inmediato de dependencias para \`${dependency_file}\`."
            fi
          } >> "$GITHUB_STEP_SUMMARY"

  # Este job se ejecuta cuando hay PRs de Dependabot y auto_approve está habilitado
  auto-approve-dependabot:
    needs: check-dependencies
    if: ${{ inputs.auto_approve == true }}
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - name: Auto-approve Dependabot PRs
        uses: hmarr/auto-approve-action@v3
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          review-message: "Auto-aprobado por el workflow de Dependabot"

  # Este job se ejecuta cuando hay PRs de Dependabot y auto_merge está habilitado
  auto-merge-dependabot:
    needs: [check-dependencies]
    if: ${{ inputs.auto_merge == true }}
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: write
    steps:
      - name: Auto-merge Dependabot PRs
        run: |
          set -euo pipefail

          label='${{ inputs.auto_merge_label }}'
          search_query="author:app/dependabot"
          if [ -n "$label" ]; then
            search_query="$search_query label:$label"
          fi

          prs=$(gh pr list --repo "${{ github.repository }}" --state open --search "$search_query" --json number --jq '.[].number')

          if [ -z "$prs" ]; then
            echo "No se encontraron PRs de Dependabot para fusionar"
            exit 0
          fi

          while IFS= read -r pr_number; do
            echo "Auto-merge del PR #$pr_number"
            gh pr merge "$pr_number" --auto --merge --repo "${{ github.repository }}"
          done <<< "$prs"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}