name: Setup Dependabot Configuration

on:
  workflow_call:
    inputs:
      package_ecosystem:
        required: true
        type: string
        description: 'Package ecosystem (npm, pip, docker, github-actions, etc.)'
      
      directory:
        required: false
        type: string
        default: '/'
        description: 'Directory path relative to repository root'
      
      schedule_interval:
        required: false
        type: string
        default: 'weekly'
        description: 'Update frequency (daily, weekly, monthly)'
      
      allow_major_versions:
        required: false
        type: boolean
        default: false
        description: 'Allow major version updates'
      
      open_pull_requests_limit:
        required: false
        type: number
        default: 5
        description: 'Maximum number of open pull requests (1-10)'
      
      target_branch:
        required: false
        type: string
        default: ''
        description: 'Target branch for updates (defaults to repository default branch)'
      
      commit_message_prefix:
        required: false
        type: string
        default: 'chore'
        description: 'Commit message prefix (chore, ci, build, etc.)'
      
      labels:
        required: false
        type: string
        default: 'dependencies'
        description: 'Comma-separated labels for Dependabot PRs'
      
      reviewers:
        required: false
        type: string
        default: ''
        description: 'Comma-separated list of reviewers (usernames)'
      
      assignees:
        required: false
        type: string
        default: ''
        description: 'Comma-separated list of assignees (usernames)'
      
      milestone:
        required: false
        type: number
        default: 0
        description: 'Milestone number to assign to PRs'
      
      versioning_strategy:
        required: false
        type: string
        default: 'auto'
        description: 'Versioning strategy (auto, increase, increase-if-necessary, widen, lockfile-only)'

jobs:
  setup-dependabot:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.target_branch || github.event.repository.default_branch }}
          fetch-depth: 1
        continue-on-error: false
      
      - name: Validate inputs
        id: validate
        run: |
          set -euo pipefail
          
          echo "üîç Validating workflow inputs..."
          
          # Validar ecosistema
          valid_ecosystems=(
            "bundler" "cargo" "composer" "docker" "elm" "gitsubmodule"
            "github-actions" "gomod" "gradle" "maven" "mix" "npm"
            "nuget" "pip" "pub" "terraform" "devcontainers"
          )
          
          ecosystem="${{ inputs.package_ecosystem }}"
          if [[ ! " ${valid_ecosystems[*]} " =~ " ${ecosystem} " ]]; then
            echo "‚ùå Invalid package ecosystem: $ecosystem"
            echo "Valid options: ${valid_ecosystems[*]}"
            exit 1
          fi
          echo "‚úÖ Ecosystem validated: $ecosystem"
          
          # Validar intervalo
          valid_intervals=("daily" "weekly" "monthly")
          interval="${{ inputs.schedule_interval }}"
          if [[ ! " ${valid_intervals[*]} " =~ " ${interval} " ]]; then
            echo "‚ùå Invalid schedule interval: $interval"
            echo "Valid options: ${valid_intervals[*]}"
            exit 1
          fi
          echo "‚úÖ Interval validated: $interval"
          
          # Validar l√≠mite de PRs
          pr_limit=${{ inputs.open_pull_requests_limit }}
          if [[ $pr_limit -lt 1 || $pr_limit -gt 10 ]]; then
            echo "‚ùå Invalid PR limit: $pr_limit (must be between 1-10)"
            exit 1
          fi
          echo "‚úÖ PR limit validated: $pr_limit"
          
          # Validar versioning strategy
          valid_strategies=("auto" "increase" "increase-if-necessary" "widen" "lockfile-only")
          strategy="${{ inputs.versioning_strategy }}"
          if [[ ! " ${valid_strategies[*]} " =~ " ${strategy} " ]]; then
            echo "‚ùå Invalid versioning strategy: $strategy"
            echo "Valid options: ${valid_strategies[*]}"
            exit 1
          fi
          echo "‚úÖ Versioning strategy validated: $strategy"
          
          # Normalizar directorio
          directory="${{ inputs.directory }}"
          directory="${directory#./}"  # Remover ./ al inicio
          directory="${directory%/}"   # Remover / al final
          
          if [[ -z "$directory" || "$directory" == "." ]]; then
            directory="/"
          elif [[ ! "$directory" =~ ^/ ]]; then
            directory="/$directory"
          fi
          
          echo "normalized_directory=$directory" >> $GITHUB_OUTPUT
          echo "‚úÖ Directory normalized: $directory"
          
          # Determinar branch objetivo
          target_branch="${{ inputs.target_branch }}"
          if [[ -z "$target_branch" ]]; then
            target_branch="${{ github.event.repository.default_branch }}"
          fi
          echo "target_branch=$target_branch" >> $GITHUB_OUTPUT
          echo "‚úÖ Target branch: $target_branch"
          
          # Validar commit message prefix
          valid_prefixes=("chore" "ci" "build" "docs" "feat" "fix" "refactor" "style" "test")
          prefix="${{ inputs.commit_message_prefix }}"
          if [[ ! " ${valid_prefixes[*]} " =~ " ${prefix} " ]]; then
            echo "‚ö†Ô∏è Non-conventional commit prefix: $prefix (continuing anyway)"
          fi
          
          echo "üéâ All validations passed!"
      
      - name: Check if manifest file exists
        id: check_manifest
        continue-on-error: true
        run: |
          set -euo pipefail
          
          ecosystem="${{ inputs.package_ecosystem }}"
          directory="${{ steps.validate.outputs.normalized_directory }}"
          
          # Mapear ecosistema a archivos manifesto
          declare -A manifest_files=(
            ["npm"]="package.json"
            ["yarn"]="package.json"
            ["pnpm"]="package.json"
            ["pip"]="requirements.txt|setup.py|Pipfile|pyproject.toml"
            ["pipenv"]="Pipfile"
            ["poetry"]="pyproject.toml"
            ["maven"]="pom.xml"
            ["gradle"]="build.gradle|build.gradle.kts"
            ["cargo"]="Cargo.toml"
            ["composer"]="composer.json"
            ["gomod"]="go.mod"
            ["bundler"]="Gemfile"
            ["docker"]="Dockerfile"
            ["github-actions"]=".github/workflows"
            ["terraform"]="*.tf"
            ["nuget"]="*.csproj|*.fsproj|*.vbproj|packages.config"
          )
          
          manifest="${manifest_files[$ecosystem]:-}"
          
          if [[ -z "$manifest" ]]; then
            echo "‚ö†Ô∏è No default manifest defined for $ecosystem"
            echo "manifest_found=unknown" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Construir ruta completa
          if [[ "$directory" == "/" ]]; then
            search_path="."
          else
            search_path=".${directory}"
          fi
          
          # Buscar archivos (soporta m√∫ltiples opciones con |)
          IFS='|' read -ra PATTERNS <<< "$manifest"
          found=false
          
          for pattern in "${PATTERNS[@]}"; do
            if [[ "$pattern" == *"*"* ]]; then
              # Patr√≥n con wildcard
              if compgen -G "${search_path}/${pattern}" > /dev/null; then
                found=true
                echo "‚úÖ Found manifest matching: $pattern in $search_path"
                break
              fi
            else
              # Archivo espec√≠fico
              if [[ -f "${search_path}/${pattern}" ]]; then
                found=true
                echo "‚úÖ Found manifest: ${search_path}/${pattern}"
                break
              fi
            fi
          done
          
          if [[ "$found" == true ]]; then
            echo "manifest_found=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è No manifest file found in $search_path"
            echo "Expected one of: $manifest"
            echo "manifest_found=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Create .github directory
        run: |
          mkdir -p .github
          echo "‚úÖ .github directory ready"
      
      - name: Generate Dependabot configuration
        id: generate_config
        run: |
          set -euo pipefail
          
          config_file=".github/dependabot.yml"
          
          echo "üìù Generating Dependabot configuration..."
          
          # Verificar si ya existe configuraci√≥n
          merge_mode="create"
          if [[ -f "$config_file" ]]; then
            merge_mode="merge"
            echo "‚ÑπÔ∏è Existing configuration found, will merge"
            cp "$config_file" "${config_file}.backup"
          fi
          
          # Generar nueva entrada
          cat > "${config_file}.new" << 'EOF'
          version: 2
          updates:
            - package-ecosystem: "${{ inputs.package_ecosystem }}"
              directory: "${{ steps.validate.outputs.normalized_directory }}"
              schedule:
                interval: "${{ inputs.schedule_interval }}"
          EOF
          
          # A√±adir configuraciones opcionales
          cat >> "${config_file}.new" << EOF
              open-pull-requests-limit: ${{ inputs.open_pull_requests_limit }}
              target-branch: "${{ steps.validate.outputs.target_branch }}"
          EOF
          
          # A√±adir labels si est√°n especificadas
          if [[ -n "${{ inputs.labels }}" ]]; then
            echo "              labels:" >> "${config_file}.new"
            IFS=',' read -ra LABELS <<< "${{ inputs.labels }}"
            for label in "${LABELS[@]}"; do
              label=$(echo "$label" | xargs)  # Trim whitespace
              echo "                - \"$label\"" >> "${config_file}.new"
            done
          fi
          
          # A√±adir reviewers
          if [[ -n "${{ inputs.reviewers }}" ]]; then
            echo "              reviewers:" >> "${config_file}.new"
            IFS=',' read -ra REVIEWERS <<< "${{ inputs.reviewers }}"
            for reviewer in "${REVIEWERS[@]}"; do
              reviewer=$(echo "$reviewer" | xargs)
              echo "                - \"$reviewer\"" >> "${config_file}.new"
            done
          fi
          
          # A√±adir assignees
          if [[ -n "${{ inputs.assignees }}" ]]; then
            echo "              assignees:" >> "${config_file}.new"
            IFS=',' read -ra ASSIGNEES <<< "${{ inputs.assignees }}"
            for assignee in "${ASSIGNEES[@]}"; do
              assignee=$(echo "$assignee" | xargs)
              echo "                - \"$assignee\"" >> "${config_file}.new"
            done
          fi
          
          # A√±adir milestone
          if [[ ${{ inputs.milestone }} -gt 0 ]]; then
            echo "              milestone: ${{ inputs.milestone }}" >> "${config_file}.new"
          fi
          
          # A√±adir versioning strategy si no es auto
          if [[ "${{ inputs.versioning_strategy }}" != "auto" ]]; then
            echo "              versioning-strategy: ${{ inputs.versioning_strategy }}" >> "${config_file}.new"
          fi
          
          # Ignorar versiones mayores si est√° configurado
          if [[ "${{ inputs.allow_major_versions }}" == "false" ]]; then
            cat >> "${config_file}.new" << 'EOF'
              ignore:
                - dependency-name: "*"
                  update-types: ["version-update:semver-major"]
          EOF
          fi
          
          # Si es modo merge, necesitamos combinar configs
          if [[ "$merge_mode" == "merge" ]]; then
            echo "üîÑ Merging with existing configuration..."
            # TODO: Implementar merge inteligente si es necesario
            # Por ahora, sobrescribimos
            mv "${config_file}.new" "$config_file"
          else
            mv "${config_file}.new" "$config_file"
          fi
          
          echo "‚úÖ Configuration generated successfully"
          echo ""
          echo "üìÑ Configuration content:"
          cat "$config_file"
          
          echo "config_path=$config_file" >> $GITHUB_OUTPUT
      
      - name: Validate configuration with GitHub API
        id: validate_config
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          retries: 3
          retry-exempt-status-codes: 400,401,403,404,422
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');
            
            const configPath = '${{ steps.generate_config.outputs.config_path }}';
            
            try {
              // Leer y parsear YAML
              const configContent = fs.readFileSync(configPath, 'utf8');
              const config = yaml.load(configContent);
              
              // Validaciones b√°sicas
              if (config.version !== 2) {
                throw new Error('Invalid version. Must be 2');
              }
              
              if (!config.updates || !Array.isArray(config.updates)) {
                throw new Error('Missing or invalid updates array');
              }
              
              if (config.updates.length === 0) {
                throw new Error('At least one update configuration required');
              }
              
              // Validar cada entrada
              for (const [index, update] of config.updates.entries()) {
                if (!update['package-ecosystem']) {
                  throw new Error(`Update ${index}: missing package-ecosystem`);
                }
                
                if (!update.directory) {
                  throw new Error(`Update ${index}: missing directory`);
                }
                
                if (!update.schedule || !update.schedule.interval) {
                  throw new Error(`Update ${index}: missing schedule.interval`);
                }
              }
              
              console.log('‚úÖ Configuration validation passed');
              core.setOutput('valid', 'true');
              
              // Generar summary
              core.summary
                .addHeading('‚úÖ Configuration Valid', 3)
                .addCodeBlock(configContent, 'yaml')
                .write();
              
              return true;
              
            } catch (error) {
              console.error('‚ùå Configuration validation failed:', error.message);
              core.setOutput('valid', 'false');
              core.setOutput('error', error.message);
              
              core.summary
                .addHeading('‚ùå Configuration Invalid', 3)
                .addRaw(`Error: ${error.message}`)
                .write();
              
              throw error;
            }
      
      - name: Commit configuration
        id: commit
        uses: actions/github-script@v7
        with:
          retries: 3
          retry-exempt-status-codes: 409,422
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            const configPath = '${{ steps.generate_config.outputs.config_path }}';
            const ecosystem = '${{ inputs.package_ecosystem }}';
            const directory = '${{ steps.validate.outputs.normalized_directory }}';
            const commitPrefix = '${{ inputs.commit_message_prefix }}';
            
            // Configurar git
            execSync('git config user.name "github-actions[bot]"');
            execSync('git config user.email "github-actions[bot]@users.noreply.github.com"');
            
            // Verificar cambios
            try {
              execSync(`git diff --quiet ${configPath}`);
              console.log('‚ÑπÔ∏è No changes detected in configuration');
              core.setOutput('committed', 'false');
              core.setOutput('no_changes', 'true');
              return;
            } catch (error) {
              // Hay cambios, continuar
            }
            
            // Preparar commit
            const commitMessage = `${commitPrefix}: configure Dependabot for ${ecosystem} in ${directory}
            
            - Package ecosystem: ${ecosystem}
            - Directory: ${directory}
            - Schedule: ${{ inputs.schedule_interval }}
            - Allow major versions: ${{ inputs.allow_major_versions }}
            
            [skip ci]`;
            
            try {
              execSync(`git add ${configPath}`);
              execSync(`git commit -m "${commitMessage}"`);
              
              // Retry logic para push
              let pushed = false;
              let attempts = 0;
              const maxAttempts = 3;
              
              while (!pushed && attempts < maxAttempts) {
                try {
                  attempts++;
                  console.log(`üì§ Push attempt ${attempts}/${maxAttempts}...`);
                  
                  // Pull con rebase antes de push
                  if (attempts > 1) {
                    execSync('git pull --rebase origin ${{ steps.validate.outputs.target_branch }}');
                  }
                  
                  execSync('git push origin HEAD:${{ steps.validate.outputs.target_branch }}');
                  pushed = true;
                  console.log('‚úÖ Configuration committed and pushed successfully');
                  
                } catch (pushError) {
                  if (attempts >= maxAttempts) {
                    throw pushError;
                  }
                  console.log(`‚ö†Ô∏è Push failed, retrying... (${attempts}/${maxAttempts})`);
                  await new Promise(resolve => setTimeout(resolve, 2000 * attempts));
                }
              }
              
              core.setOutput('committed', 'true');
              core.setOutput('no_changes', 'false');
              
            } catch (error) {
              console.error('‚ùå Failed to commit configuration:', error.message);
              throw error;
            }
      
      - name: Trigger Dependabot scan (optional)
        if: steps.commit.outputs.committed == 'true'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          retries: 3
          script: |
            const ecosystem = '${{ inputs.package_ecosystem }}';
            const directory = '${{ steps.validate.outputs.normalized_directory }}';
            const targetBranch = '${{ steps.validate.outputs.target_branch }}';
            
            console.log('üîÑ Requesting immediate Dependabot scan...');
            
            try {
              await github.rest.dependabot.createAlert({
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
              console.log('‚úÖ Dependabot scan triggered');
            } catch (error) {
              console.log('‚ÑπÔ∏è Could not trigger immediate scan (this is optional)');
              console.log('Dependabot will run on the next scheduled interval');
            }
      
      - name: Generate summary
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## ü§ñ Dependabot Configuration Summary
          
          ### Configuration Details
          
          | Setting | Value |
          |---------|-------|
          | **Repository** | `${{ github.repository }}` |
          | **Ecosystem** | `${{ inputs.package_ecosystem }}` |
          | **Directory** | `${{ steps.validate.outputs.normalized_directory }}` |
          | **Schedule** | `${{ inputs.schedule_interval }}` |
          | **Target Branch** | `${{ steps.validate.outputs.target_branch }}` |
          | **PR Limit** | `${{ inputs.open_pull_requests_limit }}` |
          | **Allow Major Versions** | `${{ inputs.allow_major_versions }}` |
          | **Versioning Strategy** | `${{ inputs.versioning_strategy }}` |
          EOF
          
          # A√±adir informaci√≥n de manifest
          if [[ "${{ steps.check_manifest.outputs.manifest_found }}" == "true" ]]; then
            echo "| **Manifest File** | ‚úÖ Found |" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ steps.check_manifest.outputs.manifest_found }}" == "false" ]]; then
            echo "| **Manifest File** | ‚ö†Ô∏è Not found (verify path) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| **Manifest File** | ‚ÑπÔ∏è Not checked |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # A√±adir labels si existen
          if [[ -n "${{ inputs.labels }}" ]]; then
            echo "| **Labels** | \`${{ inputs.labels }}\` |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # A√±adir reviewers si existen
          if [[ -n "${{ inputs.reviewers }}" ]]; then
            echo "| **Reviewers** | \`${{ inputs.reviewers }}\` |" >> $GITHUB_STEP_SUMMARY
          fi
          
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          
          ### Status
          
          EOF
          
          if [[ "${{ steps.commit.outputs.committed }}" == "true" ]]; then
            cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ‚úÖ **Configuration successfully committed**
          
          Dependabot will start scanning on the next scheduled run.
          EOF
          elif [[ "${{ steps.commit.outputs.no_changes }}" == "true" ]]; then
            cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ‚ÑπÔ∏è **No changes detected**
          
          Configuration is already up to date.
          EOF
          else
            cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ‚ùå **Configuration failed**
          
          Check the workflow logs for details.
          EOF
          fi
          
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          
          ### Next Steps
          
          1. üîç Monitor Dependabot activity in [Insights ‚Üí Dependency graph ‚Üí Dependabot](https://github.com/${{ github.repository }}/network/updates)
          2. üì¨ Review and merge PRs as they are created
          3. üîê Check [Security Advisories](https://github.com/${{ github.repository }}/security/dependabot) for vulnerabilities
          
          ### Useful Links
          
          - [Dependabot Documentation](https://docs.github.com/en/code-security/dependabot)
          - [Configuration Options](https://docs.github.com/en/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file)
          - [Repository Settings](https://github.com/${{ github.repository }}/settings/security_analysis)
          EOF
      
      - name: Comment on failure
        if: failure() && github.event_name == 'workflow_dispatch'
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const runUrl = `https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}`;
            
            github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: `‚ùå Dependabot configuration failed\n\nCheck the [workflow run](${runUrl}) for details.`
            });
