name: Reusable Dependabot Workflow

# Documentación del Workflow
# =========================
# Este workflow permite automatizar la gestión de dependencias utilizando Dependabot.
# Características principales:
# - Configurable para diferentes ecosistemas (npm, pip, maven, etc.)
# - Puede ejecutarse bajo demanda o con programación
# - Configurable para auto-aprobar y auto-fusionar actualizaciones
# - Simple y directo para integrarse en pipelines de CI/CD

on:
  workflow_call:
    inputs:
      # Parámetros de configuración general
      package_ecosystem:
        required: true
        type: string
        description: 'Ecosistema de paquetes (npm, pip, maven, docker, etc.)'
      directory:
        required: true
        type: string
        description: 'Directorio donde se encuentra el archivo de dependencias'
      dependency_file_path:
        required: false
        type: string
        default: ''
        description: 'Ruta exacta del archivo de dependencias relativa al repositorio. Si se omite, se detecta automáticamente para ecosistemas conocidos'
      schedule_interval:
        required: false
        type: string
        default: ''
        description: 'Frecuencia de verificación (daily, weekly, monthly). Si está vacío, se ejecuta bajo demanda'
      open_pull_requests_limit:
        required: false
        type: number
        default: 10
        description: 'Límite de PRs abiertos simultáneamente'
      
      # Parámetros para auto-aprobación y auto-fusión
      auto_approve:
        required: false
        type: boolean
        default: false
        description: 'Aprobar automáticamente PRs de Dependabot'
      auto_merge:
        required: false
        type: boolean
        default: false
        description: 'Fusionar automáticamente PRs de Dependabot'
      auto_merge_label:
        required: false
        type: string
        default: 'dependencies'
        description: 'Etiqueta que deben tener los PRs de Dependabot para ser auto-fusionados. Dejar vacío para no filtrar por etiqueta'
      
      # Parámetros para configuración de versiones
      allow_major_versions:
        required: false
        type: boolean
        default: false
        description: 'Permitir actualizaciones de versiones mayores'

jobs:
  check-dependencies:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Setup Dependabot configuration
        id: setup_dependabot_config
        env:
          PACKAGE_ECOSYSTEM: ${{ inputs.package_ecosystem }}
          DIRECTORY: ${{ inputs.directory }}
          SCHEDULE_INTERVAL: ${{ inputs.schedule_interval }}
          OPEN_PULL_REQUESTS_LIMIT: ${{ inputs.open_pull_requests_limit }}
          ALLOW_MAJOR_VERSIONS: ${{ inputs.allow_major_versions }}
          TARGET_BRANCH: ${{ github.event.repository.default_branch || github.ref_name }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          DEPENDENCY_FILE_OVERRIDE: ${{ inputs.dependency_file_path }}
        run: |
          set -euo pipefail
          mkdir -p .github

          api_resource="/repos/${GITHUB_REPOSITORY}/contents/.github/dependabot.yml"

          upsert_entry_in_config() {
            local entry_file="$1"
            local attempts=0

            while [ $attempts -lt 5 ]; do
              local config_json
              config_json=$(gh api -H "Accept: application/vnd.github+json" \
                "${api_resource}?ref=${TARGET_BRANCH}" 2>/dev/null || true)

              if ! command -v base64 >/dev/null 2>&1; then
                echo "base64 no está disponible en el runner" >&2
                return 1
              fi

              if [ -n "$config_json" ] && ! command -v jq >/dev/null 2>&1; then
                echo "jq no está disponible en el runner" >&2
                return 1
              fi

              local current_sha=""
              local filtered_file
              filtered_file=$(mktemp)
              local match_file
              match_file=$(mktemp)

              if [ -z "$config_json" ]; then
                printf "version: 2\nupdates:\n" > "$filtered_file"
              else
                current_sha=$(printf '%s' "$config_json" | jq -r '.sha // empty')
                local encoded
                encoded=$(printf '%s' "$config_json" | jq -r '.content // empty')

                if [ -z "$encoded" ]; then
                  printf "version: 2\nupdates:\n" > "$filtered_file"
                else
                  local existing_file
                  existing_file=$(mktemp)
                  printf '%s' "$encoded" | tr -d '\n' | base64 --decode > "$existing_file"

                  awk -v eco="$PACKAGE_ECOSYSTEM" -v dir="$DIRECTORY" -v match_file="$match_file" '
                    function flush_entry() {
                      if (entry_len == 0)
                        return
                      if (eco_match && dir_match) {
                        if (!match_written) {
                          for (i = 1; i <= entry_len; ++i)
                            print entry[i] >> match_file
                          match_written = 1
                        }
                      } else {
                        for (i = 1; i <= entry_len; ++i)
                          print entry[i]
                      }
                      entry_len = 0
                      eco_match = 0
                      dir_match = 0
                      in_entry = 0
                    }

                    /^  - package-ecosystem:/ {
                      flush_entry()
                      in_entry = 1
                      entry_len = 0
                    }

                    {
                      if (in_entry) {
                        entry[++entry_len] = $0
                        if ($0 ~ /^  - package-ecosystem:/ && $0 ~ \"\" eco \"\"/)
                          eco_match = 1
                        if ($0 ~ /^    directory:/ && $0 ~ \"\" dir \"\"/)
                          dir_match = 1
                      } else {
                        print $0
                      }
                    }

                    END {
                      flush_entry()
                    }
                  ' "$existing_file" > "$filtered_file"

                  rm -f "$existing_file"
                fi
              fi

              if [ -s "$match_file" ] && cmp -s "$match_file" "$entry_file"; then
                rm -f "$filtered_file" "$match_file"
                return 0
              fi

              local final_file
              final_file=$(mktemp)
              printf "version: 2\nupdates:\n" > "$final_file"
              if [ -s "$filtered_file" ]; then
                awk 'NR>2 {print}' "$filtered_file" >> "$final_file"
              fi
              cat "$entry_file" >> "$final_file"

              local content_b64
              content_b64=$(base64 < "$final_file" | tr -d '\n')

              local args=(
                -X PUT
                "${api_resource}"
                --raw-field "message=chore: Configure Dependabot for ${PACKAGE_ECOSYSTEM} ${DIRECTORY}"
                --raw-field "content=${content_b64}"
                --raw-field "branch=${TARGET_BRANCH}"
              )
              if [ -n "$current_sha" ]; then
                args+=(--raw-field "sha=${current_sha}")
              fi

              if gh api "${args[@]}" >/dev/null; then
                rm -f "$filtered_file" "$match_file" "$final_file"
                return 0
              fi

              rm -f "$filtered_file" "$match_file" "$final_file"
              attempts=$((attempts + 1))
              sleep 1
            done

            return 1
          }

          remove_entry_from_config() {
            local attempts=0

            while [ $attempts -lt 5 ]; do
              local config_json
              config_json=$(gh api -H "Accept: application/vnd.github+json" \
                "${api_resource}?ref=${TARGET_BRANCH}" 2>/dev/null || true)

              if [ -z "$config_json" ]; then
                return 0
              fi

              if ! command -v jq >/dev/null 2>&1; then
                echo "jq no está disponible en el runner" >&2
                return 1
              fi

              if ! command -v base64 >/dev/null 2>&1; then
                echo "base64 no está disponible en el runner" >&2
                return 1
              fi

              local current_sha
              current_sha=$(printf '%s' "$config_json" | jq -r '.sha // empty')
              local encoded
              encoded=$(printf '%s' "$config_json" | jq -r '.content // empty')

              if [ -z "$current_sha" ] || [ -z "$encoded" ]; then
                return 0
              fi

              local existing_file
              existing_file=$(mktemp)
              local filtered_file
              filtered_file=$(mktemp)

              printf '%s' "$encoded" | tr -d '\n' | base64 --decode > "$existing_file"

              awk -v eco="$PACKAGE_ECOSYSTEM" -v dir="$DIRECTORY" '
                function flush_entry() {
                  if (entry_len == 0)
                    return
                  if (!(eco_match && dir_match)) {
                    for (i = 1; i <= entry_len; ++i)
                      print entry[i]
                  }
                  entry_len = 0
                  eco_match = 0
                  dir_match = 0
                  in_entry = 0
                }

                /^  - package-ecosystem:/ {
                  flush_entry()
                  in_entry = 1
                  entry_len = 0
                }

                {
                  if (in_entry) {
                    entry[++entry_len] = $0
                    if ($0 ~ /^  - package-ecosystem:/ && $0 ~ "\"" eco "\"")
                      eco_match = 1
                    if ($0 ~ /^    directory:/ && $0 ~ "\"" dir "\"")
                      dir_match = 1
                  } else {
                    print $0
                  }
                }

                END {
                  flush_entry()
                }
              ' "$existing_file" > "$filtered_file"

              if cmp -s "$existing_file" "$filtered_file"; then
                rm -f "$existing_file" "$filtered_file"
                return 0
              fi

              local update_message="chore: Sincronizar configuración de Dependabot (${PACKAGE_ECOSYSTEM} ${DIRECTORY})"

              if grep -q '^  - ' "$filtered_file"; then
                local updated_b64
                updated_b64=$(base64 < "$filtered_file" | tr -d '\n')

                if gh api -X PUT "${api_resource}" \
                  --raw-field "message=${update_message}" \
                  --raw-field "content=${updated_b64}" \
                  --raw-field "branch=${TARGET_BRANCH}" \
                  --raw-field "sha=${current_sha}" >/dev/null; then
                  rm -f "$existing_file" "$filtered_file"
                  return 0
                fi
              else
                local delete_message="chore: Eliminar configuración de Dependabot sin intervalos"
                if gh api -X DELETE "${api_resource}" \
                  --raw-field "message=${delete_message}" \
                  --raw-field "sha=${current_sha}" \
                  --raw-field "branch=${TARGET_BRANCH}" >/dev/null; then
                  rm -f "$existing_file" "$filtered_file"
                  return 0
                fi
              fi

              rm -f "$existing_file" "$filtered_file"

              attempts=$((attempts + 1))
              sleep 1
            done

            return 1
          }

          raw_interval="${SCHEDULE_INTERVAL:-}"
          case "$raw_interval" in
            "''"|'""')
              raw_interval=""
              ;;
          esac
          raw_interval=$(printf '%s' "$raw_interval" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
          SCHEDULE_INTERVAL="$raw_interval"

          config_error=""
          config_entry="${PACKAGE_ECOSYSTEM}:${DIRECTORY}"
          if [ -n "$SCHEDULE_INTERVAL" ]; then
            case "$SCHEDULE_INTERVAL" in
              daily|weekly|monthly|quarterly|semiannually|yearly|cron)
                ;;
              *)
                config_error="Intervalo no válido para Dependabot: $SCHEDULE_INTERVAL"
                echo "$config_error" >&2
                echo "config_written=false" >> "$GITHUB_OUTPUT"
                echo "config_entry=" >> "$GITHUB_OUTPUT"
                echo "config_error=$config_error" >> "$GITHUB_OUTPUT"
                exit 1
                ;;
            esac
          fi

          if [ -z "${SCHEDULE_INTERVAL}" ]; then
            echo "Se omitió la configuración de dependabot.yml para ejecuciones bajo demanda" >> "$GITHUB_STEP_SUMMARY"
            echo "config_written=false" >> "$GITHUB_OUTPUT"
            echo "config_entry=${config_entry}" >> "$GITHUB_OUTPUT"
            echo "config_error=" >> "$GITHUB_OUTPUT"

            if ! remove_entry_from_config; then
              config_error="No se pudo sincronizar .github/dependabot.yml"
              echo "config_error=$config_error" >> "$GITHUB_OUTPUT"
              exit 1
            fi
          else
            entry_file="$RUNNER_TEMP/dependabot_entry.yml"
            {
              printf "  - package-ecosystem: \"%s\"\n" "$PACKAGE_ECOSYSTEM"
              printf "    directory: \"%s\"\n" "$DIRECTORY"
              printf "    schedule:\n"
              printf "      interval: \"%s\"\n" "$SCHEDULE_INTERVAL"
              printf "    open-pull-requests-limit: %s\n" "$OPEN_PULL_REQUESTS_LIMIT"
            } > "$entry_file"

            if [ "${ALLOW_MAJOR_VERSIONS}" != "true" ]; then
              {
                printf "    ignore:\n"
                printf "      - dependency-name: \"*\"\n"
                printf "        update-types:\n"
                printf "          - version-update:semver-major\n"
              } >> "$entry_file"
            fi

            if ! upsert_entry_in_config "$entry_file"; then
              config_error="No se pudo actualizar .github/dependabot.yml"
              echo "config_written=false" >> "$GITHUB_OUTPUT"
              echo "config_entry=${PACKAGE_ECOSYSTEM}:${DIRECTORY}" >> "$GITHUB_OUTPUT"
              echo "config_error=$config_error" >> "$GITHUB_OUTPUT"
              rm -f "$entry_file"
              exit 1
            fi

            rm -f "$entry_file"
            echo "config_written=true" >> "$GITHUB_OUTPUT"
            echo "config_entry=${PACKAGE_ECOSYSTEM}:${DIRECTORY}" >> "$GITHUB_OUTPUT"
            echo "config_error=" >> "$GITHUB_OUTPUT"
          fi

          manifest="$DEPENDENCY_FILE_OVERRIDE"
          if [ -z "$manifest" ]; then
            case "$PACKAGE_ECOSYSTEM" in
              npm|yarn|pnpm)
                manifest="package.json"
                ;;
              pip)
                manifest="requirements.txt"
                ;;
              poetry)
                manifest="pyproject.toml"
                ;;
              maven)
                manifest="pom.xml"
                ;;
              gradle)
                manifest="build.gradle"
                ;;
              gradle-kotlin)
                manifest="build.gradle.kts"
                ;;
              cargo)
                manifest="Cargo.toml"
                ;;
              composer)
                manifest="composer.json"
                ;;
              gomod)
                manifest="go.mod"
                ;;
              bundler)
                manifest="Gemfile"
                ;;
              docker)
                manifest="Dockerfile"
                ;;
              github-actions)
                manifest=".github/workflows"
                ;;
              *)
                echo "No se pudo determinar el archivo de dependencias para el ecosistema '$PACKAGE_ECOSYSTEM'." >&2
                echo "Proporciona 'dependency_file_path' al invocar el workflow." >&2
                exit 1
                ;;
            esac
          fi

          dir="$DIRECTORY"
          if [ "$dir" = "/" ]; then
            dir=""
          else
            dir="${dir#/}"
            dir="${dir%/}"
          fi

          if [ -n "$dir" ]; then
            dependency_path="$dir/$manifest"
          else
            dependency_path="$manifest"
          fi

          echo "Archivo de dependencias resuelto: $dependency_path" >> "$GITHUB_STEP_SUMMARY"
          echo "dependency_file=$dependency_path" >> "$GITHUB_OUTPUT"
          echo "DEPENDENCY_FILE=$dependency_path" >> "$GITHUB_ENV"
      
      # Si no hay schedule_interval, ejecutar verificación inmediata
      - name: Run immediate dependency check
        if: ${{ inputs.schedule_interval == '' }}
        run: |
          set -euo pipefail

          norm_dir="${DIRECTORY}"
          if [ -z "$norm_dir" ] || [ "$norm_dir" = "/" ] || [ "$norm_dir" = "." ]; then
            norm_dir="/"
          else
            norm_dir="/${norm_dir#/}"
            norm_dir="${norm_dir%/}"
            if [ -z "$norm_dir" ]; then
              norm_dir="/"
            fi
          fi

          echo "Solicitando actualización inmediata de Dependabot para $PACKAGE_ECOSYSTEM en $norm_dir"

          if output=$(gh api -X POST \
            -H "Accept: application/vnd.github+json" \
            "/repos/${GITHUB_REPOSITORY}/dependabot/updates" \
            -f package-ecosystem="$PACKAGE_ECOSYSTEM" \
            -f directory="$norm_dir" \
            -f target-branch="$TARGET_BRANCH" \
            2>&1); then
            echo "✅ Dependabot procesará una actualización inmediata para $PACKAGE_ECOSYSTEM en $norm_dir" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "$output" >&2
            echo "⚠️ No se pudo solicitar la actualización inmediata para $PACKAGE_ECOSYSTEM en $norm_dir. Verifica que Dependabot Alerts/Updates esté habilitado y que el repositorio tenga permisos suficientes." >> "$GITHUB_STEP_SUMMARY"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PACKAGE_ECOSYSTEM: ${{ inputs.package_ecosystem }}
          DIRECTORY: ${{ inputs.directory }}
          TARGET_BRANCH: ${{ github.event.repository.default_branch || github.ref_name }}

      - name: Resumen del workflow
        if: ${{ always() }}
        env:
          JOB_STATUS: ${{ job.status }}
          INPUT_SCHEDULE_INTERVAL: ${{ inputs.schedule_interval }}
          INPUT_PACKAGE_ECOSYSTEM: ${{ inputs.package_ecosystem }}
          INPUT_DIRECTORY: ${{ inputs.directory }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CONFIG_WRITTEN: ${{ steps.setup_dependabot_config.outputs.config_written }}
          CONFIG_ENTRY: ${{ steps.setup_dependabot_config.outputs.config_entry }}
          CONFIG_ERROR: ${{ steps.setup_dependabot_config.outputs.config_error }}
        run: |
          set -euo pipefail

          status_icon="✅"
          status_text="Ejecución completada"

          if [ "${JOB_STATUS}" != "success" ]; then
            status_icon="❌"
            status_text="Ejecución con errores"
          fi

          dependency_file="${DEPENDENCY_FILE:-No determinado}"

          if [ "${CONFIG_WRITTEN}" = "true" ]; then
            mode="Programado (configuración escrita)"
            archivo=".github/dependabot.yml (${CONFIG_ENTRY:-entrada registrada})"
          else
            mode="Bajo demanda (escaneo inmediato)"
            archivo="$dependency_file"
          fi

          {
            echo "## 🚀 Resumen de Dependabot"
            echo ""
            echo "| 🧩 Clave | Valor |"
            echo "| --- | --- |"
            echo "| Repositorio | \`${GITHUB_REPOSITORY}\` |"
            echo "| Directorio | \`${INPUT_DIRECTORY}\` |"
            echo "| Ecosistema | \`${INPUT_PACKAGE_ECOSYSTEM}\` |"
            echo "| Estado | ${status_icon} ${status_text} |"
            echo "| Modo | ${mode} |"
            echo "| Archivo evaluado | \`${archivo}\` |"
          } >> "$GITHUB_STEP_SUMMARY"

          pr_table=$(gh pr list --repo "$GITHUB_REPOSITORY" --state open --search "author:app/dependabot" --limit 20 --json number,title,url,baseRefName --jq '
            if length == 0 then
              ""
            else
              (["| Número | Título | Rama base | URL |","| --- | --- | --- | --- |"] +
                (map("| #" + (.number|tostring) + " | " + (.title|gsub("\\|";"\\|")) + " | " + .baseRefName + " | " + .url + " |")))
                | join("\n")
            end' )

          {
            echo ""
            if [ -z "$pr_table" ]; then
              echo "_No se encontraron PRs abiertos de Dependabot en este momento._"
            else
              echo "### 📬 PRs abiertos de Dependabot"
              echo ""
              echo "$pr_table"
            fi

            if [ "${JOB_STATUS}" != "success" ]; then
              echo ""
              echo "❗ **Error:** ${CONFIG_ERROR:-Revisa los logs de los pasos anteriores para más detalles.}"
            elif [ "${CONFIG_WRITTEN}" = "true" ]; then
              echo ""
              echo "ℹ️ Dependabot generará PRs cuando procese esta configuración (según el intervalo definido)."
            else
              echo ""
              echo "✅ Se solicitó un escaneo inmediato de dependencias para \`${dependency_file}\`."
            fi
          } >> "$GITHUB_STEP_SUMMARY"

  # Este job se ejecuta cuando hay PRs de Dependabot y auto_approve está habilitado
  auto-approve-dependabot:
    needs: check-dependencies
    if: ${{ inputs.auto_approve == true }}
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - name: Auto-approve Dependabot PRs
        uses: hmarr/auto-approve-action@v3
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          review-message: "Auto-aprobado por el workflow de Dependabot"

  # Este job se ejecuta cuando hay PRs de Dependabot y auto_merge está habilitado
  auto-merge-dependabot:
    needs: [check-dependencies]
    if: ${{ inputs.auto_merge == true }}
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: write
    steps:
      - name: Auto-merge Dependabot PRs
        run: |
          set -euo pipefail

          label='${{ inputs.auto_merge_label }}'
          search_query="author:app/dependabot"
          if [ -n "$label" ]; then
            search_query="$search_query label:$label"
          fi

          prs=$(gh pr list --repo "${{ github.repository }}" --state open --search "$search_query" --json number --jq '.[].number')

          if [ -z "$prs" ]; then
            echo "No se encontraron PRs de Dependabot para fusionar"
            exit 0
          fi

          while IFS= read -r pr_number; do
            echo "Auto-merge del PR #$pr_number"
            gh pr merge "$pr_number" --auto --merge --repo "${{ github.repository }}"
          done <<< "$prs"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}