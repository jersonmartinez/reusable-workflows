name: Setup Dependabot

on:
  workflow_call:
    inputs:
      ecosystems:
        required: true
        type: string
        description: 'JSON con configuraciones de ecosistemas'

      schedule:
        required: false
        type: string
        default: 'weekly'
        description: 'Frecuencia de actualizaciones (daily, weekly, monthly)'

      pr_limit:
        required: false
        type: number
        default: 5
        description: 'MÃ¡ximo de PRs abiertos simultÃ¡neamente'

      auto_merge:
        required: false
        type: boolean
        default: false
        description: 'Habilitar auto-merge para actualizaciones menores'

      target_branch:
        required: false
        type: string
        default: ''
        description: 'Rama objetivo para PRs (vacÃ­o = rama predeterminada)'

jobs:
  configure:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: read
      pull-requests: read

    steps:
      - name: ğŸš€ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ” Validate Labels
        id: validate_labels
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          cat > /tmp/validate_labels.py << 'SCRIPT_EOF'
          import json, os, subprocess, sys, random, string
          from collections import defaultdict

          # Obtener labels existentes del repositorio
          repo = os.getenv('GITHUB_REPOSITORY')

          try:
              result = subprocess.run(
                  ['gh', 'label', 'list', '--repo', repo, '--json', 'name,color,description', '--limit', '1000'],
                  capture_output=True,
                  text=True,
                  check=True
              )
              labels_data = json.loads(result.stdout)
              existing_labels = {label['name'].lower(): label for label in labels_data}
              print(f"::notice title=Labels Disponibles::ğŸ“‹ {len(existing_labels)} labels encontrados en el repositorio")
          except Exception as e:
              print(f"::error title=Error API::No se pudieron obtener los labels: {e}")
              existing_labels = {}

          # Parsear ecosistemas
          try:
              ecosystems = json.loads('''${{ inputs.ecosystems }}''')
          except json.JSONDecodeError as e:
              print(f"::error title=JSON InvÃ¡lido::Error al parsear ecosistemas: {e}")
              sys.exit(1)

          # Validar labels por ecosistema
          validation_results = []
          all_missing_labels = {}
          all_valid_labels = {}
          ecosystems_without_labels = []

          for eco in ecosystems:
              if 'labels' not in eco or not eco['labels']:
                  continue

              requested_labels = [l.strip() for l in eco['labels'].split(',')]
              valid_labels_info = []
              invalid_labels_info = []

              for label in requested_labels:
                  if label.lower() in existing_labels:
                      label_data = existing_labels[label.lower()]
                      valid_labels_info.append({
                          'name': label_data['name'],
                          'color': label_data.get('color', '000000'),
                          'description': label_data.get('description', '')
                      })
                      all_valid_labels[label] = label_data
                  else:
                      invalid_labels_info.append(label)
                      all_missing_labels[label] = {
                          'name': label,
                          'ecosystems': []
                      }

              # Agregar ecosistema a labels faltantes
              for label in invalid_labels_info:
                  all_missing_labels[label]['ecosystems'].append(f"{eco['ecosystem']} ({eco.get('directory', '/')})")

              validation_results.append({
                  'ecosystem': eco['ecosystem'],
                  'directory': eco.get('directory', '/'),
                  'prefix': eco.get('prefix', ''),
                  'pr_limit': eco.get('pr_limit', '${{ inputs.pr_limit }}'),
                  'valid_labels': valid_labels_info,
                  'invalid_labels': invalid_labels_info,
                  'all_valid': len(invalid_labels_info) == 0
              })

              if invalid_labels_info:
                  print(f"::warning title={eco['ecosystem']} ({eco.get('directory', '/')})::Labels faltantes: {', '.join(invalid_labels_info)}")

          # Generar ecosistemas sin labels invÃ¡lidos
          validated_ecosystems = []
          for eco in ecosystems:
              eco_copy = eco.copy()
              
              if 'labels' in eco_copy and eco_copy['labels']:
                  requested_labels = [l.strip() for l in eco_copy['labels'].split(',')]
                  valid_labels = [existing_labels[l.lower()]['name'] for l in requested_labels if l.lower() in existing_labels]
                  
                  if valid_labels:
                      eco_copy['labels'] = valid_labels
                  else:
                      ecosystems_without_labels.append(f"{eco['ecosystem']} ({eco.get('directory', '/')})")
                      del eco_copy['labels']
              
              validated_ecosystems.append(eco_copy)

          # Outputs con delimitadores seguros
          delimiter = ''.join(random.choices(string.ascii_uppercase + string.digits, k=16))
          
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"validated_ecosystems<<{delimiter}\n")
              f.write(json.dumps(validated_ecosystems, indent=2))
              f.write(f"\n{delimiter}\n")
              
              f.write(f"validation_results<<{delimiter}\n")
              f.write(json.dumps(validation_results, indent=2))
              f.write(f"\n{delimiter}\n")
              
              f.write(f"missing_labels_data<<{delimiter}\n")
              f.write(json.dumps(all_missing_labels, indent=2))
              f.write(f"\n{delimiter}\n")
              
              f.write(f"valid_labels_data<<{delimiter}\n")
              f.write(json.dumps(all_valid_labels, indent=2))
              f.write(f"\n{delimiter}\n")
              
              f.write(f"has_missing_labels={'true' if all_missing_labels else 'false'}\n")
              f.write(f"missing_labels_count={len(all_missing_labels)}\n")
              f.write(f"valid_labels_count={len(all_valid_labels)}\n")
              f.write(f"validation_status={'success' if all([v['all_valid'] for v in validation_results]) else 'partial'}\n")

          if ecosystems_without_labels:
              print(f"::warning title=Ecosistemas sin Labels::Los siguientes ecosistemas no tendrÃ¡n labels: {', '.join(ecosystems_without_labels)}")

          print("âœ… ValidaciÃ³n completada")
          SCRIPT_EOF

          python3 /tmp/validate_labels.py

      - name: âš™ï¸ Generate Dependabot Config
        id: generate
        env:
          VALIDATED_ECOSYSTEMS: ${{ steps.validate_labels.outputs.validated_ecosystems }}
          SCHEDULE_INTERVAL: ${{ inputs.schedule }}
          DEFAULT_PR_LIMIT: ${{ inputs.pr_limit }}
          AUTO_MERGE: ${{ inputs.auto_merge }}
          TARGET_BRANCH: ${{ inputs.target_branch }}
        run: |
          cat > /tmp/generate_config.py << 'SCRIPT_EOF'
          import yaml, json, sys, os, random, string
          from pathlib import Path
          from datetime import datetime

          validated_json = os.getenv('VALIDATED_ECOSYSTEMS', '[]')
          schedule = os.getenv('SCHEDULE_INTERVAL', 'weekly')
          default_pr_limit = int(os.getenv('DEFAULT_PR_LIMIT', '5'))
          auto_merge = os.getenv('AUTO_MERGE', 'false').lower() == 'true'
          target_branch = os.getenv('TARGET_BRANCH', '').strip()
          
          try:
              ecosystems = json.loads(validated_json)
          except json.JSONDecodeError as e:
              print(f"::error title=JSON InvÃ¡lido::Error al parsear ecosistemas: {e}")
              sys.exit(1)

          if not ecosystems:
              print(f"::error title=Sin Ecosistemas::No hay ecosistemas para configurar")
              sys.exit(1)

          print(f"::debug::Procesando {len(ecosystems)} ecosistemas")

          updates = []
          for eco in ecosystems:
              config = {
                  'package-ecosystem': eco['ecosystem'],
                  'directory': eco.get('directory', '/'),
                  'schedule': {'interval': eco.get('schedule', schedule)}
              }

              if 'labels' in eco and eco['labels']:
                  labels = eco['labels'] if isinstance(eco['labels'], list) else [l.strip() for l in eco['labels'].split(',')]
                  if labels:
                      config['labels'] = labels
                      print(f"::debug::âœ“ {eco['ecosystem']} ({config['directory']}): {len(labels)} labels")

              if 'pr_limit' in eco:
                  config['open-pull-requests-limit'] = eco['pr_limit']
              else:
                  config['open-pull-requests-limit'] = default_pr_limit

              if 'prefix' in eco and eco['prefix']:
                  config['commit-message'] = {'prefix': eco['prefix']}

              if target_branch:
                  config['target-branch'] = target_branch

              # ğŸ¯ NUEVA CARACTERÃSTICA: Auto-merge para actualizaciones menores
              if auto_merge:
                  config['pull-request-branch-name'] = {
                      'separator': '-'
                  }
                  # Nota: El auto-merge real se configura en el repositorio

              updates.append(config)
              print(f"::debug::âœ“ Configurado: {eco['ecosystem']} ({config['directory']})")

          dependabot_config = {
              'version': 2,
              'updates': updates
          }

          Path('.github').mkdir(exist_ok=True)
          config_path = Path('.github/dependabot.yml')
          
          with open(config_path, 'w') as f:
              yaml.dump(dependabot_config, f, sort_keys=False, default_flow_style=False, allow_unicode=True)

          print(f"âœ… ConfiguraciÃ³n generada: {config_path}")
          print(f"::notice title=Archivo Generado::ğŸ“ {config_path} ({len(updates)} ecosistemas)")

          # Outputs
          delimiter = ''.join(random.choices(string.ascii_uppercase + string.digits, k=16))
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"config_path={config_path}\n")
              f.write(f"ecosystems_count={len(updates)}\n")
              f.write(f"schedule={schedule}\n")
              f.write(f"timestamp={datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}\n")
              f.write(f"auto_merge_enabled={'true' if auto_merge else 'false'}\n")
              f.write(f"target_branch={target_branch if target_branch else 'default'}\n")
          SCRIPT_EOF

          python3 /tmp/generate_config.py

      - name: ğŸ’¾ Commit Changes
        id: commit
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          if git diff --quiet .github/dependabot.yml; then
            echo "changes_detected=false" >> $GITHUB_OUTPUT
            echo "commit_hash=N/A" >> $GITHUB_OUTPUT
            echo "commit_status=sin-cambios" >> $GITHUB_OUTPUT
            echo "commit_url=N/A" >> $GITHUB_OUTPUT
            echo "::notice title=Sin Cambios::âœ… La configuraciÃ³n ya estÃ¡ actualizada"
          else
            git add .github/dependabot.yml
            git commit -m "chore(deps): update dependabot configuration

            - Updated by workflow: ${{ github.workflow }}
            - Run ID: ${{ github.run_id }}
            - Timestamp: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
            
            git push
            
            COMMIT_SHA=$(git rev-parse HEAD)
            COMMIT_URL="https://github.com/${{ github.repository }}/commit/${COMMIT_SHA}"
            echo "changes_detected=true" >> $GITHUB_OUTPUT
            echo "commit_hash=$COMMIT_SHA" >> $GITHUB_OUTPUT
            echo "commit_status=actualizado" >> $GITHUB_OUTPUT
            echo "commit_url=$COMMIT_URL" >> $GITHUB_OUTPUT
            echo "::notice title=Commit Realizado::âœ… ConfiguraciÃ³n actualizada (${COMMIT_SHA:0:7})"
          fi

      - name: â³ Wait for Dependabot Scan
        if: steps.commit.outputs.changes_detected == 'true'
        run: |
          echo "â³ Esperando 15 segundos para que Dependabot detecte los cambios..."
          sleep 15

      - name: ğŸ”„ Check Dependabot PRs
        id: check_prs
        if: steps.commit.outputs.changes_detected == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          cat > /tmp/check_prs.py << 'SCRIPT_EOF'
          import json, subprocess, os, random, string
          from datetime import datetime

          repo = os.getenv('GITHUB_REPOSITORY')

          try:
              # Obtener PRs recientes de Dependabot
              result = subprocess.run(
                  ['gh', 'pr', 'list', 
                   '--repo', repo,
                   '--author', 'app/dependabot',
                   '--state', 'open',
                   '--json', 'number,title,url,createdAt,labels',
                   '--limit', '20'],
                  capture_output=True,
                  text=True,
                  check=True
              )
              
              prs = json.loads(result.stdout)
              
              # Ordenar por fecha de creaciÃ³n (mÃ¡s recientes primero)
              prs.sort(key=lambda x: x['createdAt'], reverse=True)
              
              delimiter = ''.join(random.choices(string.ascii_uppercase + string.digits, k=16))
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write(f"dependabot_prs<<{delimiter}\n")
                  f.write(json.dumps(prs, indent=2))
                  f.write(f"\n{delimiter}\n")
                  f.write(f"has_prs={'true' if prs else 'false'}\n")
                  f.write(f"prs_count={len(prs)}\n")
              
              print(f"âœ… Encontrados {len(prs)} PRs de Dependabot")
              
          except Exception as e:
              print(f"::warning title=No se pudieron obtener PRs::Error: {e}")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("has_prs=false\n")
                  f.write("prs_count=0\n")
          SCRIPT_EOF

          python3 /tmp/check_prs.py

      - name: ğŸ“Š Generate Enhanced Summary
        if: always()
        env:
          VALIDATION_RESULTS: ${{ steps.validate_labels.outputs.validation_results }}
          MISSING_LABELS_DATA: ${{ steps.validate_labels.outputs.missing_labels_data }}
          VALID_LABELS_DATA: ${{ steps.validate_labels.outputs.valid_labels_data }}
          HAS_MISSING_LABELS: ${{ steps.validate_labels.outputs.has_missing_labels }}
          MISSING_LABELS_COUNT: ${{ steps.validate_labels.outputs.missing_labels_count }}
          VALID_LABELS_COUNT: ${{ steps.validate_labels.outputs.valid_labels_count }}
          ECOSYSTEMS_COUNT: ${{ steps.generate.outputs.ecosystems_count }}
          SCHEDULE: ${{ steps.generate.outputs.schedule }}
          TIMESTAMP: ${{ steps.generate.outputs.timestamp }}
          COMMIT_STATUS: ${{ steps.commit.outputs.commit_status }}
          COMMIT_SHA: ${{ steps.commit.outputs.commit_hash }}
          COMMIT_URL: ${{ steps.commit.outputs.commit_url }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
          DEPENDABOT_PRS: ${{ steps.check_prs.outputs.dependabot_prs }}
          HAS_DEPENDABOT_PRS: ${{ steps.check_prs.outputs.has_prs }}
          PRS_COUNT: ${{ steps.check_prs.outputs.prs_count }}
          AUTO_MERGE_ENABLED: ${{ steps.generate.outputs.auto_merge_enabled }}
          TARGET_BRANCH: ${{ steps.generate.outputs.target_branch }}
        run: |
          cat > /tmp/generate_summary.py << 'SCRIPT_EOF'
          import json, os
          from datetime import datetime

          # Parsear datos
          try:
              validation_results = json.loads(os.getenv('VALIDATION_RESULTS', '[]'))
          except:
              validation_results = []

          try:
              dependabot_prs = json.loads(os.getenv('DEPENDABOT_PRS', '[]'))
          except:
              dependabot_prs = []

          try:
              missing_labels_data = json.loads(os.getenv('MISSING_LABELS_DATA', '{}'))
          except:
              missing_labels_data = {}

          try:
              valid_labels_data = json.loads(os.getenv('VALID_LABELS_DATA', '{}'))
          except:
              valid_labels_data = {}

          has_missing = os.getenv('HAS_MISSING_LABELS') == 'true'
          missing_labels_count = os.getenv('MISSING_LABELS_COUNT', '0')
          valid_labels_count = os.getenv('VALID_LABELS_COUNT', '0')
          ecosystems_count = os.getenv('ECOSYSTEMS_COUNT', '0')
          schedule = os.getenv('SCHEDULE', 'weekly')
          timestamp = os.getenv('TIMESTAMP', 'N/A')
          commit_status = os.getenv('COMMIT_STATUS', 'desconocido')
          commit_sha = os.getenv('COMMIT_SHA', 'N/A')
          commit_url = os.getenv('COMMIT_URL', 'N/A')
          repo = os.getenv('GITHUB_REPOSITORY')
          branch = os.getenv('GITHUB_REF_NAME')
          has_dependabot_prs = os.getenv('HAS_DEPENDABOT_PRS') == 'true'
          prs_count = os.getenv('PRS_COUNT', '0')
          auto_merge = os.getenv('AUTO_MERGE_ENABLED', 'false') == 'true'
          target_branch = os.getenv('TARGET_BRANCH', 'default')

          # Iconos por ecosistema
          ecosystem_icons = {
              'pip': 'ğŸ',
              'npm': 'ğŸ“¦',
              'docker': 'ğŸ³',
              'github-actions': 'âš¡',
              'composer': 'ğŸ¼',
              'bundler': 'ğŸ’',
              'cargo': 'ğŸ¦€',
              'gomod': 'ğŸ¹',
              'gradle': 'ğŸ˜',
              'maven': 'â˜•',
              'nuget': 'ğŸ“˜',
              'terraform': 'ğŸ—ï¸',
              'mix': 'ğŸ’§',
              'pub': 'ğŸ¯'
          }

          # Badge de estado
          if commit_status == 'actualizado':
              status_badge = 'ğŸŸ¢ **Actualizado**'
          elif commit_status == 'sin-cambios':
              status_badge = 'ğŸ”µ **Sin Cambios**'
          else:
              status_badge = 'âšª **Desconocido**'

          summary_parts = []
          
          # Header principal con diseÃ±o mejorado
          summary_parts.append("# ğŸ“¦ Dependabot Configuration Report\n\n")
          summary_parts.append("> **ConfiguraciÃ³n automÃ¡tica de Dependabot completada**\n\n")
          summary_parts.append("---\n\n")

          # SecciÃ³n: Resumen Ejecutivo (diseÃ±o compacto)
          summary_parts.append("### ğŸ“‹ Resumen Ejecutivo\n\n")
          summary_parts.append("<table>\n")
          summary_parts.append("<tr>\n")
          summary_parts.append(f"<td><b>ğŸ”§ Ecosistemas</b></td>\n")
          summary_parts.append(f"<td><code>{ecosystems_count}</code></td>\n")
          summary_parts.append(f"<td><b>ğŸ“… Frecuencia</b></td>\n")
          summary_parts.append(f"<td><code>{schedule}</code></td>\n")
          summary_parts.append("</tr>\n")
          summary_parts.append("<tr>\n")
          summary_parts.append(f"<td><b>ğŸ“ Estado</b></td>\n")
          summary_parts.append(f"<td>{status_badge}</td>\n")
          summary_parts.append(f"<td><b>ğŸ•’ Ejecutado</b></td>\n")
          summary_parts.append(f"<td><code>{timestamp}</code></td>\n")
          summary_parts.append("</tr>\n")
          
          if commit_sha != 'N/A' and commit_url != 'N/A':
              summary_parts.append("<tr>\n")
              summary_parts.append(f"<td><b>ğŸ”— Commit</b></td>\n")
              summary_parts.append(f"<td colspan='3'><a href='{commit_url}'><code>{commit_sha[:7]}</code></a> â€¢ <a href='https://github.com/{repo}/blob/{branch}/.github/dependabot.yml'>Ver configuraciÃ³n</a></td>\n")
              summary_parts.append("</tr>\n")
          
          if auto_merge:
              summary_parts.append("<tr>\n")
              summary_parts.append(f"<td><b>ğŸ¤– Auto-merge</b></td>\n")
              summary_parts.append(f"<td>âœ… Habilitado</td>\n")
              summary_parts.append(f"<td><b>ğŸ¯ Rama objetivo</b></td>\n")
              summary_parts.append(f"<td><code>{target_branch}</code></td>\n")
              summary_parts.append("</tr>\n")
          
          summary_parts.append("</table>\n\n")
          summary_parts.append("---\n\n")

          # âœ¨ NUEVA SECCIÃ“N: EstadÃ­sticas de Labels
          summary_parts.append("### ğŸ·ï¸ EstadÃ­sticas de Labels\n\n")
          summary_parts.append("<table>\n")
          summary_parts.append("<tr>\n")
          summary_parts.append(f"<td align='center'><h3>âœ… {valid_labels_count}</h3><b>VÃ¡lidos</b></td>\n")
          summary_parts.append(f"<td align='center'><h3>âš ï¸ {missing_labels_count}</h3><b>Faltantes</b></td>\n")
          summary_parts.append(f"<td align='center'><h3>ğŸ¯ {int(valid_labels_count) / (int(valid_labels_count) + int(missing_labels_count)) * 100 if (int(valid_labels_count) + int(missing_labels_count)) > 0 else 0:.0f}%</h3><b>Cobertura</b></td>\n")
          summary_parts.append("</tr>\n")
          summary_parts.append("</table>\n\n")

          # Labels VÃ¡lidos (con enlaces)
          if valid_labels_data:
              summary_parts.append("<details>\n")
              summary_parts.append(f"<summary><b>âœ… Labels Configurados ({valid_labels_count})</b></summary>\n\n")
              summary_parts.append("<br>\n\n")
              
              for label_name, label_info in sorted(valid_labels_data.items()):
                  color = label_info.get('color', '000000')
                  desc = label_info.get('description', '')
                  url = f"https://github.com/{repo}/labels/{label_info['name'].replace(' ', '%20')}"
                  
                  summary_parts.append(f"â€¢ <a href='{url}'><img src='https://img.shields.io/badge/-{label_info['name'].replace('-', '--')}-{color}?style=flat-square' alt='{label_info['name']}'></a>")
                  if desc:
                      summary_parts.append(f" <sub>{desc}</sub>")
                  summary_parts.append("\n")
              
              summary_parts.append("\n</details>\n\n")

          summary_parts.append("---\n\n")

          # PRs de Dependabot (si existen)
          if has_dependabot_prs and dependabot_prs:
              summary_parts.append("<details open>\n")
              summary_parts.append(f"<summary><b>ğŸ”„ Pull Requests Activos ({prs_count})</b></summary>\n\n")
              summary_parts.append("<br>\n\n")
              
              summary_parts.append("| PR | TÃ­tulo | Labels |\n")
              summary_parts.append("|:--:|:-------|:-------|\n")
              
              for pr in dependabot_prs:
                  number = pr['number']
                  title = pr['title'].replace('Bump ', 'â¬†ï¸ ')
                  url = pr['url']
                  labels_list = pr.get('labels', [])
                  
                  labels_badges = []
                  for lbl in labels_list[:3]:  # MÃ¡ximo 3 labels
                      label_name = lbl.get('name', '')
                      if label_name:
                          labels_badges.append(f"`{label_name}`")
                  
                  labels_display = ' '.join(labels_badges) if labels_badges else 'â€”'
                  
                  summary_parts.append(f"| [**#{number}**]({url}) | {title} | {labels_display} |\n")
              
              summary_parts.append("\n")
              summary_parts.append(f"> ğŸ’¡ **AcciÃ³n:** Revisa y fusiona estos PRs en la [pestaÃ±a Pull Requests](https://github.com/{repo}/pulls?q=is%3Apr+author%3Aapp%2Fdependabot)\n\n")
              
              summary_parts.append("</details>\n\n")
              summary_parts.append("---\n\n")

          # Ecosistemas Configurados (diseÃ±o mejorado)
          summary_parts.append("<details open>\n")
          summary_parts.append("<summary><b>ğŸ”§ Ecosistemas Configurados</b></summary>\n\n")
          summary_parts.append("<br>\n\n")
          
          if validation_results:
              for idx, result in enumerate(validation_results, 1):
                  icon = ecosystem_icons.get(result['ecosystem'], 'ğŸ“¦')
                  eco_name = result['ecosystem']
                  directory = result['directory']
                  prefix = result.get('prefix', '')
                  pr_limit = result.get('pr_limit', '5')
                  
                  summary_parts.append(f"**{idx}. {icon} {eco_name}** <sub>`{directory}`</sub>\n\n")
                  
                  summary_parts.append("<table>\n")
                  summary_parts.append("<tr>\n")
                  summary_parts.append(f"<td><b>ğŸ“Œ Prefix</b></td><td><code>{prefix if prefix else 'â€”'}</code></td>\n")
                  summary_parts.append(f"<td><b>ğŸ”¢ PR Limit</b></td><td><code>{pr_limit}</code></td>\n")
                  summary_parts.append("</tr>\n")
                  summary_parts.append("</table>\n\n")
                  
                  # Labels vÃ¡lidos
                  if result['valid_labels']:
                      summary_parts.append("**Labels aplicados:**\n\n")
                      for lbl in result['valid_labels']:
                          label_name = lbl['name']
                          color = lbl.get('color', '000000')
                          url = f"https://github.com/{repo}/labels/{label_name.replace(' ', '%20')}"
                          summary_parts.append(f"<a href='{url}'><img src='https://img.shields.io/badge/-{label_name.replace('-', '--')}-{color}?style=flat-square' alt='{label_name}'></a> ")
                      summary_parts.append("\n\n")
                  
                  # Labels omitidos
                  if result['invalid_labels']:
                      summary_parts.append("**âš ï¸ Labels omitidos:** ")
                      for lbl in result['invalid_labels']:
                          summary_parts.append(f"`{lbl}` ")
                      summary_parts.append("\n\n")
                  
                  summary_parts.append("---\n\n")
          
          summary_parts.append("</details>\n\n")
          summary_parts.append("---\n\n")

          # Labels Faltantes (diseÃ±o mejorado)
          if has_missing and missing_labels_data:
              summary_parts.append("<details open>\n")
              summary_parts.append(f"<summary><b>âš ï¸ Labels Faltantes ({missing_labels_count})</b></summary>\n\n")
              summary_parts.append("<br>\n\n")
              
              summary_parts.append("> Estos labels no existen en el repositorio y fueron omitidos de la configuraciÃ³n:\n\n")
              
              summary_parts.append("| Label | Ecosistemas Afectados |\n")
              summary_parts.append("|:------|:----------------------|\n")
              
              for label_name, label_info in sorted(missing_labels_data.items()):
                  ecosystems_affected = label_info.get('ecosystems', [])
                  eco_display = '<br>'.join([f"â€¢ {eco}" for eco in ecosystems_affected])
                  summary_parts.append(f"| **`{label_name}`** | {eco_display} |\n")
              
              summary_parts.append("\n")
              summary_parts.append(f"### ğŸ”§ AcciÃ³n Recomendada\n\n")
              summary_parts.append(f"1. **[Crear labels faltantes](https://github.com/{repo}/labels)** en el repositorio\n")
              summary_parts.append(f"2. Vuelve a ejecutar este workflow para aplicarlos\n\n")
              
              summary_parts.append("</details>\n\n")
              summary_parts.append("---\n\n")

          # Enlaces RÃ¡pidos
          summary_parts.append("<details>\n")
          summary_parts.append("<summary><b>ğŸ”— Enlaces Ãštiles</b></summary>\n\n")
          summary_parts.append("<br>\n\n")
          summary_parts.append(f"â€¢ ğŸ“‹ [Ver configuraciÃ³n generada](https://github.com/{repo}/blob/{branch}/.github/dependabot.yml)\n")
          summary_parts.append(f"â€¢ ğŸ“Š [Dependency graph](https://github.com/{repo}/network/dependencies)\n")
          summary_parts.append(f"â€¢ ğŸ”„ [PRs de Dependabot](https://github.com/{repo}/pulls?q=is%3Apr+author%3Aapp%2Fdependabot)\n")
          summary_parts.append(f"â€¢ ğŸ›¡ï¸ [Security](https://github.com/{repo}/security)\n")
          summary_parts.append(f"â€¢ ğŸ·ï¸ [Gestionar labels](https://github.com/{repo}/labels)\n")
          summary_parts.append(f"â€¢ ğŸ“š [DocumentaciÃ³n Dependabot](https://docs.github.com/en/code-security/dependabot)\n")
          summary_parts.append("\n</details>\n\n")
          summary_parts.append("---\n\n")

          # InformaciÃ³n Adicional
          summary_parts.append("<details>\n")
          summary_parts.append("<summary><b>ğŸ“– Â¿QuÃ© hace Dependabot?</b></summary>\n\n")
          summary_parts.append("<br>\n\n")
          summary_parts.append("Dependabot automatiza las actualizaciones de dependencias:\n\n")
          summary_parts.append("âœ“ **Escaneo automÃ¡tico** de dependencias segÃºn el schedule configurado\n\n")
          summary_parts.append("âœ“ **DetecciÃ³n de vulnerabilidades** y actualizaciones de seguridad\n\n")
          summary_parts.append("âœ“ **CreaciÃ³n de PRs** con las actualizaciones disponibles\n\n")
          summary_parts.append("âœ“ **Changelog automÃ¡tico** en la descripciÃ³n del PR\n\n")
          summary_parts.append("âœ“ **Compatible** con mÃºltiples lenguajes y gestores de paquetes\n\n")
          summary_parts.append("</details>\n\n")

          # PersonalizaciÃ³n
          summary_parts.append("<details>\n")
          summary_parts.append("<summary><b>âš™ï¸ Personalizar ConfiguraciÃ³n</b></summary>\n\n")
          summary_parts.append("<br>\n\n")
          summary_parts.append("Edita el workflow caller para ajustar parÃ¡metros:\n\n")
          summary_parts.append("```yaml\n")
          summary_parts.append("uses: jersonmartinez/reusable-workflows/.github/workflows/dependabot.yml@main\n")
          summary_parts.append("with:\n")
          summary_parts.append("  schedule: 'daily'           # daily, weekly, monthly\n")
          summary_parts.append("  pr_limit: 10                # LÃ­mite de PRs simultÃ¡neos\n")
          summary_parts.append("  auto_merge: true            # Habilitar auto-merge\n")
          summary_parts.append("  target_branch: 'develop'    # Rama objetivo personalizada\n")
          summary_parts.append("  ecosystems: |               # JSON con ecosistemas\n")
          summary_parts.append("    [...]\n")
          summary_parts.append("```\n\n")
          summary_parts.append("</details>\n\n")
          summary_parts.append("---\n\n")

          # Puntos de Mejora
          summary_parts.append("<details>\n")
          summary_parts.append("<summary><b>ğŸš€ Puntos de Mejora del Workflow</b></summary>\n\n")
          summary_parts.append("<br>\n\n")
          
          summary_parts.append("#### ğŸ¯ Implementadas en esta versiÃ³n:\n\n")
          summary_parts.append("âœ… **ValidaciÃ³n automÃ¡tica de labels** con detecciÃ³n inteligente\n\n")
          summary_parts.append("âœ… **Summary con diseÃ±o premium** y acordeones organizados\n\n")
          summary_parts.append("âœ… **EstadÃ­sticas visuales** de cobertura de labels\n\n")
          summary_parts.append("âœ… **Enlaces directos** a PRs, labels y configuraciÃ³n\n\n")
          summary_parts.append("âœ… **Soporte para auto-merge** (requiere configuraciÃ³n en el repo)\n\n")
          summary_parts.append("âœ… **Rama objetivo personalizable** para PRs\n\n")
          summary_parts.append("âœ… **DetecciÃ³n de PRs existentes** con metadata completa\n\n")
          
          summary_parts.append("#### ğŸ”® Futuras mejoras sugeridas:\n\n")
          summary_parts.append("ğŸ”¸ **Notificaciones Slack/Discord** cuando se crean PRs de Dependabot\n\n")
          summary_parts.append("ğŸ”¸ **Auto-aprobaciÃ³n** de PRs con actualizaciones menores (patch)\n\n")
          summary_parts.append("ğŸ”¸ **Matriz de compatibilidad** entre versiones de dependencias\n\n")
          summary_parts.append("ğŸ”¸ **Informe de vulnerabilidades** integrado con GitHub Security\n\n")
          summary_parts.append("ğŸ”¸ **HistÃ³rico de actualizaciones** en formato cronolÃ³gico\n\n")
          summary_parts.append("ğŸ”¸ **IntegraciÃ³n con SonarQube** para anÃ¡lisis de cÃ³digo\n\n")
          summary_parts.append("ğŸ”¸ **PolÃ­ticas de actualizaciÃ³n** por ecosistema (solo patches, minors, etc.)\n\n")
          summary_parts.append("ğŸ”¸ **Dashboard centralizado** para mÃºltiples repositorios\n\n")
          
          summary_parts.append("#### ğŸ“ Mejoras de configuraciÃ³n:\n\n")
          summary_parts.append("ğŸ”¹ Habilitar **Dependabot security updates** en Settings > Security\n\n")
          summary_parts.append("ğŸ”¹ Configurar **auto-merge** en Settings > General\n\n")
          summary_parts.append("ğŸ”¹ Crear **ruleset** para auto-aprobar PRs de Dependabot\n\n")
          summary_parts.append("ğŸ”¹ Configurar **branch protection** para merge automÃ¡tico\n\n")
          
          summary_parts.append("</details>\n\n")

          # Footer elegante
          summary_parts.append("---\n\n")
          summary_parts.append("<div align='center'>\n\n")
          summary_parts.append("**âœ¨ ConfiguraciÃ³n completada exitosamente âœ¨**\n\n")
          summary_parts.append(f"<sub>Generado por [Reusable Workflows](https://github.com/jersonmartinez/reusable-workflows) â€¢ {timestamp}</sub>\n\n")
          summary_parts.append("</div>\n")

          # Escribir summary
          summary = ''.join(summary_parts)
          with open(os.environ['GITHUB_STEP_SUMMARY'], 'w') as f:
              f.write(summary)

          print("âœ… Summary Premium generado correctamente")
          SCRIPT_EOF

          python3 /tmp/generate_summary.py
