name: Setup Dependabot

on:
  workflow_call:
    inputs:
      ecosystems:
        required: true
        type: string
        description: 'JSON con configuraciones de ecosistemas'

      schedule:
        required: false
        type: string
        default: 'weekly'
        description: 'Frecuencia de actualizaciones (daily, weekly, monthly)'

      pr_limit:
        required: false
        type: number
        default: 5
        description: 'MÃ¡ximo de PRs abiertos simultÃ¡neamente'

jobs:
  configure:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate Labels
        id: validate_labels
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          cat > /tmp/validate_labels.py << 'SCRIPT_EOF'
          import json, os, subprocess, sys, random, string
          from collections import defaultdict

          # Obtener labels existentes del repositorio
          repo = os.getenv('GITHUB_REPOSITORY')

          try:
              result = subprocess.run(
                  ['gh', 'label', 'list', '--repo', repo, '--json', 'name', '--limit', '1000'],
                  capture_output=True,
                  text=True,
                  check=True
              )
              existing_labels = {label['name'].lower() for label in json.loads(result.stdout)}
              print(f"::notice title=Labels Disponibles::ğŸ“‹ {len(existing_labels)} labels encontrados en el repositorio")
          except Exception as e:
              print(f"::error title=Error API::No se pudieron obtener los labels: {e}")
              existing_labels = set()

          # Parsear ecosistemas
          try:
              ecosystems = json.loads('''${{ inputs.ecosystems }}''')
          except json.JSONDecodeError as e:
              print(f"::error title=JSON InvÃ¡lido::Error al parsear ecosistemas: {e}")
              sys.exit(1)

          # Validar labels por ecosistema
          validation_results = []
          all_missing_labels = set()
          ecosystems_without_labels = []

          for eco in ecosystems:
              if 'labels' not in eco or not eco['labels']:
                  continue

              requested_labels = [l.strip() for l in eco['labels'].split(',')]
              valid_labels = []
              invalid_labels = []

              for label in requested_labels:
                  if label.lower() in existing_labels:
                      valid_labels.append(label)
                  else:
                      invalid_labels.append(label)
                      all_missing_labels.add(label)

              validation_results.append({
                  'ecosystem': eco['ecosystem'],
                  'directory': eco.get('directory', '/'),
                  'requested_labels': requested_labels,
                  'valid_labels': valid_labels,
                  'invalid_labels': invalid_labels,
                  'valid_labels_count': len(valid_labels),
                  'invalid_labels_count': len(invalid_labels),
                  'all_valid': len(invalid_labels) == 0
              })

              if invalid_labels:
                  print(f"::warning title={eco['ecosystem']} ({eco.get('directory', '/')})::Labels faltantes: {', '.join(invalid_labels)}")

          # Generar ecosistemas sin labels invÃ¡lidos
          validated_ecosystems = []
          for eco in ecosystems:
              eco_copy = eco.copy()
              
              if 'labels' in eco_copy and eco_copy['labels']:
                  requested_labels = [l.strip() for l in eco_copy['labels'].split(',')]
                  valid_labels = [l for l in requested_labels if l.lower() in existing_labels]
                  
                  if valid_labels:
                      eco_copy['labels'] = valid_labels
                  else:
                      ecosystems_without_labels.append(f"{eco['ecosystem']} ({eco.get('directory', '/')})")
                      del eco_copy['labels']
              
              validated_ecosystems.append(eco_copy)

          # Outputs con delimitadores seguros
          delimiter = ''.join(random.choices(string.ascii_uppercase + string.digits, k=16))
          
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"validated_ecosystems<<{delimiter}\n")
              f.write(json.dumps(validated_ecosystems, indent=2))
              f.write(f"\n{delimiter}\n")
              
              f.write(f"validation_results<<{delimiter}\n")
              f.write(json.dumps(validation_results, indent=2))
              f.write(f"\n{delimiter}\n")
              
              f.write(f"missing_labels={','.join(sorted(all_missing_labels))}\n")
              f.write(f"has_missing_labels={'true' if all_missing_labels else 'false'}\n")
              f.write(f"validation_status={'success' if all([v['all_valid'] for v in validation_results]) else 'partial'}\n")
              f.write(f"ecosystems_without_labels={','.join(ecosystems_without_labels)}\n")

          if ecosystems_without_labels:
              print(f"::warning title=Ecosistemas sin Labels::Los siguientes ecosistemas no tendrÃ¡n labels: {', '.join(ecosystems_without_labels)}")

          print("âœ… ValidaciÃ³n completada")
          SCRIPT_EOF

          python3 /tmp/validate_labels.py

      - name: Generate Dependabot Config
        id: generate
        env:
          VALIDATED_ECOSYSTEMS: ${{ steps.validate_labels.outputs.validated_ecosystems }}
          SCHEDULE_INTERVAL: ${{ inputs.schedule }}
          DEFAULT_PR_LIMIT: ${{ inputs.pr_limit }}
        run: |
          cat > /tmp/generate_config.py << 'SCRIPT_EOF'
          import yaml, json, sys, os, random, string
          from pathlib import Path
          from datetime import datetime

          validated_json = os.getenv('VALIDATED_ECOSYSTEMS', '[]')
          schedule = os.getenv('SCHEDULE_INTERVAL', 'weekly')
          default_pr_limit = int(os.getenv('DEFAULT_PR_LIMIT', '5'))
          
          try:
              ecosystems = json.loads(validated_json)
          except json.JSONDecodeError as e:
              print(f"::error title=JSON InvÃ¡lido::Error al parsear ecosistemas: {e}")
              sys.exit(1)

          if not ecosystems:
              print(f"::error title=Sin Ecosistemas::No hay ecosistemas para configurar")
              sys.exit(1)

          print(f"::debug::Procesando {len(ecosystems)} ecosistemas")

          updates = []
          for eco in ecosystems:
              config = {
                  'package-ecosystem': eco['ecosystem'],
                  'directory': eco.get('directory', '/'),
                  'schedule': {'interval': eco.get('schedule', schedule)}
              }

              if 'labels' in eco and eco['labels']:
                  labels = eco['labels'] if isinstance(eco['labels'], list) else [l.strip() for l in eco['labels'].split(',')]
                  if labels:
                      config['labels'] = labels
                      print(f"::debug::âœ“ {eco['ecosystem']} ({config['directory']}): {len(labels)} labels")

              if 'pr_limit' in eco:
                  config['open-pull-requests-limit'] = eco['pr_limit']
              else:
                  config['open-pull-requests-limit'] = default_pr_limit

              if 'prefix' in eco:
                  config['commit-message'] = {'prefix': eco['prefix']}

              updates.append(config)
              print(f"::debug::âœ“ Configurado: {eco['ecosystem']} ({config['directory']})")

          dependabot_config = {
              'version': 2,
              'updates': updates
          }

          Path('.github').mkdir(exist_ok=True)
          config_path = Path('.github/dependabot.yml')
          
          with open(config_path, 'w') as f:
              yaml.dump(dependabot_config, f, sort_keys=False, default_flow_style=False, allow_unicode=True)

          print(f"âœ… ConfiguraciÃ³n generada: {config_path}")
          print(f"::notice title=Archivo Generado::ğŸ“ {config_path} ({len(updates)} ecosistemas)")

          # Outputs
          delimiter = ''.join(random.choices(string.ascii_uppercase + string.digits, k=16))
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"config_path={config_path}\n")
              f.write(f"ecosystems_count={len(updates)}\n")
              f.write(f"schedule={schedule}\n")
              f.write(f"timestamp={datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}\n")
          SCRIPT_EOF

          python3 /tmp/generate_config.py

      - name: Commit Changes
        id: commit
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          if git diff --quiet .github/dependabot.yml; then
            echo "changes_detected=false" >> $GITHUB_OUTPUT
            echo "commit_hash=N/A" >> $GITHUB_OUTPUT
            echo "commit_status=sin-cambios" >> $GITHUB_OUTPUT
            echo "::notice title=Sin Cambios::âœ… La configuraciÃ³n ya estÃ¡ actualizada"
          else
            git add .github/dependabot.yml
            git commit -m "chore(deps): update dependabot configuration

            - Updated by workflow: ${{ github.workflow }}
            - Run ID: ${{ github.run_id }}
            - Timestamp: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
            
            git push
            
            COMMIT_SHA=$(git rev-parse HEAD)
            echo "changes_detected=true" >> $GITHUB_OUTPUT
            echo "commit_hash=$COMMIT_SHA" >> $GITHUB_OUTPUT
            echo "commit_status=actualizado" >> $GITHUB_OUTPUT
            echo "::notice title=Commit Realizado::âœ… ConfiguraciÃ³n actualizada (${COMMIT_SHA:0:7})"
          fi

      - name: Generate Summary
        if: always()
        env:
          VALIDATION_RESULTS: ${{ steps.validate_labels.outputs.validation_results }}
          MISSING_LABELS: ${{ steps.validate_labels.outputs.missing_labels }}
          HAS_MISSING_LABELS: ${{ steps.validate_labels.outputs.has_missing_labels }}
          ECOSYSTEMS_COUNT: ${{ steps.generate.outputs.ecosystems_count }}
          SCHEDULE: ${{ steps.generate.outputs.schedule }}
          TIMESTAMP: ${{ steps.generate.outputs.timestamp }}
          COMMIT_STATUS: ${{ steps.commit.outputs.commit_status }}
          COMMIT_SHA: ${{ steps.commit.outputs.commit_hash }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
          ECOSYSTEMS_WITHOUT_LABELS: ${{ steps.validate_labels.outputs.ecosystems_without_labels }}
        run: |
          cat > /tmp/generate_summary.py << 'SCRIPT_EOF'
          import json, os
          from datetime import datetime

          # Parsear datos
          try:
              validation_results = json.loads(os.getenv('VALIDATION_RESULTS', '[]'))
          except:
              validation_results = []

          missing_labels = [l.strip() for l in os.getenv('MISSING_LABELS', '').split(',') if l.strip()]
          has_missing = os.getenv('HAS_MISSING_LABELS') == 'true'
          ecosystems_count = os.getenv('ECOSYSTEMS_COUNT', '0')
          schedule = os.getenv('SCHEDULE', 'weekly')
          timestamp = os.getenv('TIMESTAMP', 'N/A')
          commit_status = os.getenv('COMMIT_STATUS', 'desconocido')
          commit_sha = os.getenv('COMMIT_SHA', 'N/A')
          repo = os.getenv('GITHUB_REPOSITORY')
          branch = os.getenv('GITHUB_REF_NAME')
          ecosystems_without_labels = [e.strip() for e in os.getenv('ECOSYSTEMS_WITHOUT_LABELS', '').split(',') if e.strip()]

          # Iconos por ecosistema
          ecosystem_icons = {
              'pip': 'ğŸ',
              'npm': 'ğŸ“¦',
              'docker': 'ğŸ³',
              'github-actions': 'âš¡',
              'composer': 'ğŸ¼',
              'bundler': 'ğŸ’',
              'cargo': 'ğŸ¦€',
              'gomod': 'ğŸ¹',
              'gradle': 'ğŸ˜',
              'maven': 'â˜•',
              'nuget': 'ğŸ“˜'
          }

          # Badge de estado
          if commit_status == 'actualizado':
              status_badge = 'ğŸŸ¢ **Actualizado**'
              status_color = '#28a745'
          elif commit_status == 'sin-cambios':
              status_badge = 'ğŸ”µ **Sin Cambios**'
              status_color = '#0366d6'
          else:
              status_badge = 'âšª **Desconocido**'
              status_color = '#6c757d'

          summary_parts = []
          
          # Header principal
          summary_parts.append("# ğŸ“¦ Dependabot Configuration Summary\n\n")
          summary_parts.append("---\n\n")

          # SecciÃ³n: Resumen de ConfiguraciÃ³n
          summary_parts.append("## ğŸ“Š Resumen de ConfiguraciÃ³n\n\n")
          summary_parts.append("| MÃ©trica | Valor |\n")
          summary_parts.append("|---------|-------|\n")
          summary_parts.append(f"| ğŸ”§ **Ecosistemas Configurados** | `{ecosystems_count}` |\n")
          summary_parts.append(f"| ğŸ“… **Frecuencia de ActualizaciÃ³n** | `{schedule}` |\n")
          summary_parts.append(f"| ğŸ•’ **Ejecutado el** | `{timestamp}` |\n")
          summary_parts.append(f"| ğŸ“ **Estado del Commit** | {status_badge} |\n")
          
          if commit_sha != 'N/A':
              commit_url = f"https://github.com/{repo}/commit/{commit_sha}"
              summary_parts.append(f"| ğŸ”— **Commit SHA** | [`{commit_sha[:7]}`]({commit_url}) |\n")
          else:
              summary_parts.append(f"| ğŸ”— **Commit SHA** | `{commit_sha}` |\n")
          
          summary_parts.append("\n---\n\n")

          # SecciÃ³n: Ecosistemas Configurados (accordion)
          summary_parts.append("<details open>\n")
          summary_parts.append("<summary><h2>ğŸ”§ Ecosistemas Configurados</h2></summary>\n\n")
          
          if validation_results:
              summary_parts.append("| Ecosistema | Directorio | PRs | Labels VÃ¡lidos | Labels Omitidos | Prefix |\n")
              summary_parts.append("|------------|------------|-----|----------------|-----------------|--------|\n")
              
              for result in validation_results:
                  icon = ecosystem_icons.get(result['ecosystem'], 'ğŸ“¦')
                  eco_name = f"{icon} **{result['ecosystem']}**"
                  directory = f"`{result['directory']}`"
                  valid_count = result['valid_labels_count']
                  invalid_count = result['invalid_labels_count']
                  
                  # Obtener prefix y PR limit del JSON original
                  prefix = 'â€”'
                  pr_limit = 'â€”'
                  try:
                      ecosystems = json.loads(os.getenv('VALIDATED_ECOSYSTEMS', '[]'))
                      for eco in ecosystems:
                          if eco['ecosystem'] == result['ecosystem'] and eco.get('directory') == result['directory']:
                              prefix = f"`{eco.get('prefix', 'â€”')}`"
                              pr_limit = f"`{eco.get('open-pull-requests-limit', eco.get('pr_limit', 'â€”'))}`"
                              break
                  except:
                      pass
                  
                  valid_labels_cell = f"âœ… `{valid_count}`" if valid_count > 0 else "â€”"
                  invalid_labels_cell = f"âš ï¸ `{invalid_count}`" if invalid_count > 0 else "âœ… `0`"
                  
                  summary_parts.append(f"| {eco_name} | {directory} | {pr_limit} | {valid_labels_cell} | {invalid_labels_cell} | {prefix} |\n")
          else:
              summary_parts.append("*No hay ecosistemas configurados*\n\n")
          
          summary_parts.append("\n</details>\n\n")
          summary_parts.append("---\n\n")

          # SecciÃ³n: Labels Faltantes (si existen)
          if has_missing and missing_labels:
              summary_parts.append("<details open>\n")
              summary_parts.append("<summary><h2>âš ï¸ Labels Faltantes Detectados</h2></summary>\n\n")
              
              summary_parts.append(f"> **{len(missing_labels)} label(s)** no existen en el repositorio y fueron omitidos.\n\n")
              
              # Tabla de labels faltantes
              summary_parts.append("| # | Label Faltante | Ecosistema Afectado |\n")
              summary_parts.append("|---|----------------|---------------------|\n")
              
              label_index = 1
              for result in validation_results:
                  if result['invalid_labels']:
                      eco_display = f"{ecosystem_icons.get(result['ecosystem'], 'ğŸ“¦')} `{result['ecosystem']}` (`{result['directory']}`)"
                      for label in result['invalid_labels']:
                          summary_parts.append(f"| {label_index} | `{label}` | {eco_display} |\n")
                          label_index += 1
              
              summary_parts.append("\n")
              
              # Enlace Ãºnico para crear labels
              labels_url = f"https://github.com/{repo}/labels"
              summary_parts.append(f"### ğŸ”§ AcciÃ³n Requerida\n\n")
              summary_parts.append(f"Para que estos labels se apliquen en futuros PRs de Dependabot:\n\n")
              summary_parts.append(f"1. ğŸ·ï¸ **[Crea los labels faltantes aquÃ­]({labels_url})**\n")
              summary_parts.append(f"2. ğŸ”„ Vuelve a ejecutar este workflow para actualizar la configuraciÃ³n\n\n")
              
              summary_parts.append("</details>\n\n")
              summary_parts.append("---\n\n")

          # SecciÃ³n: Enlaces Ãštiles (accordion)
          summary_parts.append("<details>\n")
          summary_parts.append("<summary><h2>ğŸ”— Enlaces Ãštiles</h2></summary>\n\n")
          summary_parts.append(f"- ğŸ“‹ [Ver configuraciÃ³n generada](https://github.com/{repo}/blob/{branch}/.github/dependabot.yml)\n")
          summary_parts.append(f"- ğŸ“Š [Dependency graph](https://github.com/{repo}/network/dependencies)\n")
          summary_parts.append(f"- ğŸ”„ [Pull requests de Dependabot](https://github.com/{repo}/pulls?q=is%3Apr+author%3Aapp%2Fdependabot)\n")
          summary_parts.append(f"- ğŸ›¡ï¸ [Security advisories](https://github.com/{repo}/security/advisories)\n")
          summary_parts.append(f"- ğŸ·ï¸ [Gestionar labels](https://github.com/{repo}/labels)\n")
          summary_parts.append("\n</details>\n\n")
          summary_parts.append("---\n\n")

          # SecciÃ³n: Â¿QuÃ© hace Dependabot? (accordion)
          summary_parts.append("<details>\n")
          summary_parts.append("<summary><h2>â“ Â¿QuÃ© hace Dependabot?</h2></summary>\n\n")
          summary_parts.append("Dependabot es un bot de GitHub que:\n\n")
          summary_parts.append("- ğŸ” **Escanea** tus dependencias automÃ¡ticamente\n")
          summary_parts.append("- ğŸ“¦ **Detecta** actualizaciones disponibles\n")
          summary_parts.append("- ğŸ”„ **Crea PRs** con las actualizaciones\n")
          summary_parts.append("- ğŸ›¡ï¸ **Identifica** vulnerabilidades de seguridad\n")
          summary_parts.append("- âš¡ **Mantiene** tu proyecto actualizado sin esfuerzo manual\n\n")
          summary_parts.append("ğŸ“š [DocumentaciÃ³n oficial](https://docs.github.com/en/code-security/dependabot)\n\n")
          summary_parts.append("</details>\n\n")
          summary_parts.append("---\n\n")

          # SecciÃ³n: Personalizar ConfiguraciÃ³n (accordion)
          summary_parts.append("<details>\n")
          summary_parts.append("<summary><h2>ğŸ› ï¸ Personalizar ConfiguraciÃ³n</h2></summary>\n\n")
          summary_parts.append("Para modificar la configuraciÃ³n, edita el workflow que llama a este reusable:\n\n")
          summary_parts.append("```yaml\n")
          summary_parts.append("with:\n")
          summary_parts.append("  schedule: 'daily'  # Cambiar frecuencia\n")
          summary_parts.append("  pr_limit: 10       # Ajustar lÃ­mite de PRs\n")
          summary_parts.append("  ecosystems: |      # Modificar ecosistemas\n")
          summary_parts.append("    [\n")
          summary_parts.append('      {"ecosystem": "pip", "directory": "/api", "labels": "dependencies,python"}\n')
          summary_parts.append("    ]\n")
          summary_parts.append("```\n\n")
          summary_parts.append("</details>\n\n")
          summary_parts.append("---\n\n")

          # Footer
          summary_parts.append("**âœ¨ ConfiguraciÃ³n completada exitosamente**\n\n")
          summary_parts.append("> ğŸ’¡ **Tip:** Usa `workflow_dispatch` para regenerar esta configuraciÃ³n manualmente cuando lo necesites.\n")

          # Escribir summary
          summary = ''.join(summary_parts)
          with open(os.environ['GITHUB_STEP_SUMMARY'], 'w') as f:
              f.write(summary)

          print("âœ… Summary generado correctamente")
          SCRIPT_EOF

          python3 /tmp/generate_summary.py
