name: Setup Dependabot

on:
  workflow_call:
    inputs:
      ecosystems:
        required: true
        type: string
        description: 'JSON con configuraciones de ecosistemas'

      schedule:
        required: false
        type: string
        default: 'weekly'
        description: 'Frecuencia de actualizaciones (daily, weekly, monthly)'

      pr_limit:
        required: false
        type: number
        default: 5
        description: 'MÃ¡ximo de PRs abiertos simultÃ¡neamente'

      target_branch:
        required: false
        type: string
        default: ''
        description: 'Rama objetivo para PRs (vacÃ­o = rama predeterminada)'

      create_issue:
        required: false
        type: boolean
        default: true
        description: 'Crear issue de reporte de hallazgos'

      issue_title:
        required: false
        type: string
        default: 'Reporte Dependabot: ${date}'
        description: 'TÃ­tulo del issue; use ${date} para fecha UTC'

      issue_labels:
        required: false
        type: string
        default: 'dependabot-report'
        description: 'Labels para el issue, separados por coma'

      close_dependabot_prs:
        required: false
        type: boolean
        default: true
        description: 'Cerrar los PRs de Dependabot tras crear el issue'

      wait_minutes:
        required: false
        type: number
        default: 10
        description: 'Minutos mÃ¡ximos para esperar PRs nuevos de Dependabot'

      create_missing_labels:
        required: false
        type: boolean
        default: false
        description: 'Crear labels faltantes antes de generar configuraciÃ³n'

      create_issue_if_empty:
        required: false
        type: boolean
        default: true
        description: 'Crear issue aunque no existan PRs detectados'

      upload_debug_artifact:
        required: false
        type: boolean
        default: true
        description: 'Subir docs/output.txt como artifact de depuraciÃ³n'

jobs:
  configure:
    name: Configuring
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write

    steps:
      - name: ğŸš€ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ•’ Marcar inicio
        run: echo "RUN_STARTED_AT=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_ENV

      - name: ğŸ§ª Preparar logs de depuraciÃ³n
        run: |
          mkdir -p docs
          printf "[START] Dependabot report debug at %s\n" "$(date -u +'%Y-%m-%d %H:%M:%SZ')" > docs/output.txt

      - name: ğŸ” Validate Labels
        id: validate_labels
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          cat > /tmp/validate_labels.py << 'SCRIPT_EOF'
          import json, os, subprocess, sys
          from collections import defaultdict

          repo = os.getenv('GITHUB_REPOSITORY')

          try:
              result = subprocess.run(
                  ['gh', 'label', 'list', '--repo', repo, '--json', 'name,color,description', '--limit', '1000'],
                  capture_output=True, text=True, check=True
              )
              labels_data = json.loads(result.stdout)
              existing_labels = {label['name'].lower(): label for label in labels_data}
          except Exception as e:
              print(f"::error::No se pudieron obtener los labels: {e}")
              existing_labels = {}

          try:
              ecosystems = json.loads('''${{ inputs.ecosystems }}''')
          except json.JSONDecodeError as e:
              print(f"::error::Error al parsear ecosistemas: {e}")
              sys.exit(1)

          missing_by_ecosystem = defaultdict(list)
          valid_by_ecosystem = defaultdict(list)
          filtered_ecosystems = []
          all_missing = set()

          for eco in ecosystems:
              labels = [l.strip() for l in eco.get('labels', '').split(',') if l.strip()]
              valid_labels = []
              
              for label in labels:
                  if label.lower() in existing_labels:
                      valid_by_ecosystem[f"{eco['ecosystem']}|{eco['directory']}"].append(label)
                      valid_labels.append(label)
                  else:
                      missing_by_ecosystem[f"{eco['ecosystem']}|{eco['directory']}"].append(label)
                      all_missing.add(label)

              # Crear ecosistema filtrado con SOLO labels vÃ¡lidos
              filtered_eco = eco.copy()
              filtered_eco['labels'] = ','.join(valid_labels)
              filtered_ecosystems.append(filtered_eco)

          # Generar outputs
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"missing_labels={','.join(sorted(all_missing))}\n")
              f.write(f"missing_count={len(all_missing)}\n")
              f.write(f"valid_count={sum(len(v) for v in valid_by_ecosystem.values())}\n")
              f.write(f"has_missing={'true' if all_missing else 'false'}\n")
              
              # Exportar ecosistemas filtrados
              filtered_json = json.dumps(filtered_ecosystems)
              f.write(f"filtered_ecosystems<<EOF\n")
              f.write(f"{filtered_json}\n")
              f.write(f"EOF\n")

          # Guardar datos para el summary
          with open('/tmp/validation_data.json', 'w') as f:
              json.dump({
                  'missing_by_ecosystem': dict(missing_by_ecosystem),
                  'valid_by_ecosystem': dict(valid_by_ecosystem),
                  'existing_labels': existing_labels
              }, f)

          if all_missing:
              print(f"::warning title=Labels Faltantes::Se encontraron {len(all_missing)} labels sin configurar. SerÃ¡n omitidos del archivo generado.")
              for label in sorted(all_missing):
                  print(f"  âš ï¸ {label}")
          else:
              print("::notice title=ValidaciÃ³n Exitosa::Todos los labels estÃ¡n configurados correctamente")
          
          print(f"\nğŸ“Š Resumen:")
          print(f"  âœ… Labels vÃ¡lidos: {sum(len(v) for v in valid_by_ecosystem.values())}")
          print(f"  âš ï¸ Labels faltantes: {len(all_missing)}")
          print(f"  ğŸ“¦ Ecosistemas: {len(ecosystems)}")
          SCRIPT_EOF

          python3 /tmp/validate_labels.py

      - name: ğŸ·ï¸ Crear labels faltantes
        if: ${{ steps.validate_labels.outputs.has_missing == 'true' && inputs.create_missing_labels }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          MISSING="${{ steps.validate_labels.outputs.missing_labels }}"
          REPO="$GITHUB_REPOSITORY"
          IFS=',' read -ra LABELS <<< "$MISSING"
          for l in "${LABELS[@]}"; do
            [ -z "$l" ] && continue
            gh label create "$l" --repo "$REPO" --color 0366d6 --description "Auto-creado para Dependabot" || true
            echo "Creado label: $l"
          done

      - name: ğŸ“ Generate Dependabot Config
        env:
          FILTERED_ECOSYSTEMS: ${{ steps.validate_labels.outputs.filtered_ecosystems }}
        run: |
          cat > /tmp/generate_config.py << 'SCRIPT_EOF'
          import json, os, sys

          try:
              ecosystems = json.loads(os.getenv('FILTERED_ECOSYSTEMS', '[]'))
          except json.JSONDecodeError as e:
              print(f"::error::JSON invÃ¡lido: {e}")
              sys.exit(1)

          if not ecosystems:
              print("::error::No hay ecosistemas para configurar")
              sys.exit(1)

          schedule = '${{ inputs.schedule }}'
          pr_limit = ${{ inputs.pr_limit }}
          target_branch = '${{ inputs.target_branch }}'

          config = {'version': 2, 'updates': []}

          for eco in ecosystems:
              update = {
                  'package-ecosystem': eco['ecosystem'],
                  'directory': eco['directory'],
                  'schedule': {'interval': schedule},
                  'open-pull-requests-limit': eco.get('pr_limit', pr_limit)
              }

              if target_branch:
                  update['target-branch'] = target_branch

              # Los labels ya estÃ¡n filtrados (solo vÃ¡lidos)
              labels = [l.strip() for l in eco.get('labels', '').split(',') if l.strip()]
              if labels:
                  update['labels'] = labels

              prefix = eco.get('prefix', '').strip()
              if prefix:
                  update['commit-message'] = {'prefix': prefix}

              config['updates'].append(update)

          import yaml
          os.makedirs('.github', exist_ok=True)

          with open('.github/dependabot.yml', 'w') as f:
            yaml.dump(config, f, sort_keys=False, default_flow_style=False, indent=2)

          print("âœ… ConfiguraciÃ³n generada exitosamente (solo con labels vÃ¡lidos)")

          with open('.github/dependabot.yml', 'r') as f:
              content = f.read()
              print("\nğŸ“„ Contenido generado:")
              print(content)
          SCRIPT_EOF

          python3 /tmp/generate_config.py

      - name: ğŸ’¾ Commit Changes
        id: commit
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          if git diff --quiet .github/dependabot.yml; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "ğŸ“Œ Sin cambios - La configuraciÃ³n estÃ¡ actualizada"
          else
            git add .github/dependabot.yml
            git commit -m "chore: update dependabot configuration"
            git push
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "commit_sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
            echo "âœ… Cambios commiteados y pusheados"
          fi

      - name: ğŸ”„ Detect Dependabot PRs
        id: detect_prs
        env:
          GH_TOKEN: ${{ github.token }}
          WAIT_MINUTES: ${{ inputs.wait_minutes }}
        run: |
          cat > /tmp/detect_prs.py << 'SCRIPT_EOF'
          import json, os, subprocess, time
          
          wait_minutes = int(os.getenv('WAIT_MINUTES', '10'))
          repo = os.getenv('GITHUB_REPOSITORY')
          debug_path = os.path.join('docs','output.txt')
          
          def log(msg):
              try:
                  with open(debug_path,'a') as df:
                      df.write(msg + "\n")
              except Exception:
                  pass
          
          def list_prs_api():
            try:
              args = [
                'gh','api','repos/'+repo+'/pulls',
                '--method','GET',
                '--field','state=open',
                '--field','per_page=100',
                '--paginate'
              ]
              result = subprocess.run(args, capture_output=True, text=True)
              if result.returncode == 0 and result.stdout.strip():
                data = json.loads(result.stdout)
                filtered = []
                for pr in data:
                  login = (pr.get('user',{}) or {}).get('login','')
                  if login in ('dependabot','dependabot[bot]','app/dependabot'):
                    filtered.append({
                      'number': pr.get('number'),
                      'title': pr.get('title'),
                      'url': pr.get('html_url'),
                      'labels': pr.get('labels',[]),
                      'createdAt': pr.get('created_at',''),
                      'headRefName': (pr.get('head',{}) or {}).get('ref','')
                    })
                return filtered
              log(f"list_prs_api non-0 returncode: {result.returncode} stderr={result.stderr.strip()}")
              return []
            except Exception as e:
              log(f"list_prs_api exception: {e}")
              return []
          
          prs = list_prs_api()
          log(f"Initial PRs count: {len(prs)}")
          if prs:
              for pr in prs:
                  log(f"PR #{pr['number']} - {pr['title']} - {pr['url']}")
          
          deadline = time.time() + wait_minutes*60
          while len(prs) == 0 and time.time() < deadline:
              time.sleep(30)
              prs = list_prs_api()
              log(f"Polling... PRs count: {len(prs)}")
          
          # Export outputs
          with open(os.environ['GITHUB_OUTPUT'],'a') as f:
              f.write('prs_data<<EOF\n')
              f.write(json.dumps(prs))
              f.write('\nEOF\n')
              f.write(f"prs_count={len(prs)}\n")
          
          print(f"ğŸ“Š PRs detectados: {len(prs)}")
          SCRIPT_EOF
          
          python3 /tmp/detect_prs.py

      - name: ğŸ§¾ Crear Issue de Reporte
        id: create_issue
        if: ${{ inputs.create_issue && (steps.detect_prs.outputs.prs_count != '0' || inputs.create_issue_if_empty) }}
        env:
          GH_TOKEN: ${{ github.token }}
          PRS_DATA: ${{ steps.detect_prs.outputs.prs_data }}
          ISSUE_TITLE_TPL: ${{ inputs.issue_title }}
          ISSUE_LABELS: ${{ inputs.issue_labels }}
        run: |
          cat > /tmp/create_issue.py << 'SCRIPT_EOF'
          import json, os, re, subprocess
          from datetime import datetime, timezone
          
          debug_path = os.path.join('docs','output.txt')
          
          def log(msg):
              try:
                  with open(debug_path,'a') as df:
                      df.write(msg + "\n")
              except Exception:
                  pass
          
          def pr_details(num, repo):
              try:
                  r = subprocess.run(['gh','pr','view',str(num),'--repo',repo,'--json','body'], capture_output=True, text=True)
                  if r.returncode == 0:
                      data = json.loads(r.stdout)
                      return data.get('body','')
                  return ''
              except Exception:
                  return ''
          
          def parse_title(t):
              m = re.search(r"bump\s+([^\s]+)\s+from\s+([^\s]+)\s+to\s+([^\s]+)(?:\s+in\s+(.+))?", t, re.IGNORECASE)
              if m:
                  return {'name': m.group(1), 'from': m.group(2), 'to': m.group(3), 'dir': m.group(4) or ''}
              return None
          
          def semver_tuple(s):
              parts = re.findall(r"\d+", s)
              nums = [int(x) for x in parts[:3]]
              while len(nums) < 3:
                  nums.append(0)
              return tuple(nums)
          
          def update_type(f, t):
              fM,fm,fp = semver_tuple(f)
              tM,tm,tp = semver_tuple(t)
              if tM != fM:
                  return 'major'
              if tm != fm:
                  return 'minor'
              if tp != fp:
                  return 'patch'
              return 'other'
          
          def build_body(prs, date, repo):
              lines = []
              lines.append(f"### Reporte de actualizaciones ({date})\n")
              if prs:
                  agg = {'major':0,'minor':0,'patch':0,'other':0}
                  lines.append("\n| PR | Paquete | Desde | Hasta | Dir | Labels |\n")
                  lines.append("|:--:|:-------|:-----:|:-----:|:---:|:------:|\n")
                  for pr in prs:
                      num = pr.get('number')
                      url = pr.get('url')
                      title_pr = pr.get('title','')
                      meta = parse_title(title_pr) or {'name':'â€”','from':'â€”','to':'â€”','dir':''}
                      labels_pr = ', '.join([l.get('name','') for l in pr.get('labels',[])]) or 'â€”'
                      lines.append(f"| [#{num}]({url}) | {meta['name']} | {meta['from']} | {meta['to']} | {meta['dir']} | {labels_pr} |\n")
                      if meta['from'] != 'â€”' and meta['to'] != 'â€”':
                          agg[update_type(meta['from'], meta['to'])] += 1
                  lines.append("\n#### Resumen por tipo\n")
                  lines.append(f"- Major: {agg['major']}\n- Minor: {agg['minor']}\n- Patch: {agg['patch']}\n- Other: {agg['other']}\n")
                  lines.append("\n#### Detalles\n")
                  for pr in prs:
                      num = pr.get('number')
                      url = pr.get('url')
                      title_pr = pr.get('title','')
                      body = pr_details(num, repo)
                      snippet = (body or '').strip()
                      if len(snippet) > 1200:
                          snippet = snippet[:1200] + 'â€¦'
                      lines.append(f"- [#{num}]({url}) {title_pr}\n")
                      if snippet:
                          lines.append(f"  \n  {snippet}\n")
              else:
                  lines.append("\nNo se encontraron PRs abiertos de Dependabot en este momento.\n")
              return ''.join(lines)
          
          def main():
              prs_raw = os.getenv('PRS_DATA','[]')
              prs = json.loads(prs_raw) if prs_raw.strip() else []
              date = datetime.now(timezone.utc).strftime('%Y-%m-%d')
              title_tpl = os.getenv('ISSUE_TITLE_TPL','Reporte Dependabot: ${date}')
              title = title_tpl.replace('${date}', date)
              labels = [l.strip() for l in os.getenv('ISSUE_LABELS','').split(',') if l.strip()]
              repo = os.getenv('GITHUB_REPOSITORY')
              body = build_body(prs, date, repo)
              cmd = ['gh','issue','create','--repo',repo,'--title',title,'--body',body]
              for l in labels:
                  cmd += ['--label', l]
              result = subprocess.run(cmd, capture_output=True, text=True)
              url = ''
              if result.returncode == 0:
                  for line in result.stdout.splitlines():
                      if line.strip().startswith('https://'):
                          url = line.strip()
                          break
              with open(os.environ['GITHUB_OUTPUT'],'a') as f:
                  f.write(f"issue_url={url}\n")
              log(f"Issue title: {title}")
              log(f"Issue created: {url if url else 'N/A'}")
              print(f"ğŸ§¾ Issue creado: {url if url else 'N/A'}")
          
          if __name__ == '__main__':
              main()
          SCRIPT_EOF
          
          python3 /tmp/create_issue.py

      - name: ğŸ›‘ Cerrar PRs de Dependabot
        if: ${{ inputs.close_dependabot_prs && steps.detect_prs.outputs.prs_count != '0' && steps.create_issue.outputs.issue_url != '' }}
        env:
          GH_TOKEN: ${{ github.token }}
          PRS_DATA: ${{ steps.detect_prs.outputs.prs_data }}
        run: |
          python3 - << 'PY'
          import json, os, subprocess
          from pathlib import Path
          prs = json.loads(os.getenv('PRS_DATA','[]'))
          closed = 0
          debug_path = Path('docs')/ 'output.txt'
          for pr in prs:
              num = pr.get('number')
              if not num:
                  continue
              repo = os.getenv('GITHUB_REPOSITORY')
              r = subprocess.run(['gh','pr','close',str(num),'--repo',repo,'--delete-branch','--comment','Cerrado por reporte consolidado de Dependabot'], capture_output=True, text=True)
              if r.returncode == 0:
                  closed += 1
                  try:
                      debug_path.parent.mkdir(parents=True, exist_ok=True)
                      with open(debug_path,'a') as df:
                          df.write(f"Closed PR #{num}\n")
                  except Exception:
                      pass
          print(f"ğŸ”’ PRs cerrados: {closed}")
          PY

      - name: ğŸ“Š Generate Summary
        env:
          PRS_DATA: ${{ steps.detect_prs.outputs.prs_data }}
          PRS_COUNT: ${{ steps.detect_prs.outputs.prs_count }}
          CHANGED: ${{ steps.commit.outputs.changed }}
          COMMIT_SHA: ${{ steps.commit.outputs.commit_sha }}
          MISSING_COUNT: ${{ steps.validate_labels.outputs.missing_count }}
          VALID_COUNT: ${{ steps.validate_labels.outputs.valid_count }}
          ISSUE_URL: ${{ steps.create_issue.outputs.issue_url }}
        run: |
          cat > /tmp/generate_summary.py << 'SCRIPT_EOF'
          import json, os
          from datetime import datetime, timezone

          repo = os.getenv('GITHUB_REPOSITORY')
          server_url = os.getenv('GITHUB_SERVER_URL', 'https://github.com')
          changed = os.getenv('CHANGED', 'false')
          commit_sha = os.getenv('COMMIT_SHA', '')
          missing_count = int(os.getenv('MISSING_COUNT', '0'))
          valid_count = int(os.getenv('VALID_COUNT', '0'))

          # Cargar datos de validaciÃ³n
          try:
              with open('/tmp/validation_data.json', 'r') as f:
                  validation_data = json.load(f)
              missing_by_ecosystem = validation_data['missing_by_ecosystem']
              valid_by_ecosystem = validation_data['valid_by_ecosystem']
              existing_labels = validation_data['existing_labels']
          except Exception as e:
              print(f"::error::No se pudo cargar validation_data.json: {e}")
              missing_by_ecosystem = {}
              valid_by_ecosystem = {}
              existing_labels = {}

          # Cargar ecosistemas originales
          try:
              ecosystems = json.loads('''${{ inputs.ecosystems }}''')
          except:
              ecosystems = []

          # Cargar PRs
          try:
              prs_raw = os.getenv('PRS_DATA', '[]')
              prs_data = json.loads(prs_raw) if prs_raw and prs_raw.strip() != '' else []
          except Exception as e:
              print(f"::debug::Error parseando PRs: {e}")
              prs_data = []

          prs_count = int(os.getenv('PRS_COUNT', '0'))

          summary = []

          # Header
          summary.append("# ğŸ¤– ConfiguraciÃ³n de Dependabot\n\n")

          # Estado
          if changed == 'true' and commit_sha:
              commit_url = f"{server_url}/{repo}/commit/{commit_sha}"
              summary.append(f"âœ… **ConfiguraciÃ³n actualizada** â€¢ Commit: [ğŸ“ `{commit_sha[:7]}`]({commit_url})\n\n")
          else:
              summary.append("â„¹ï¸ **Sin cambios** â€¢ La configuraciÃ³n estÃ¡ actualizada\n\n")

          # Resumen ejecutivo
          total_ecosystems = len(ecosystems)
          total_labels = valid_count + missing_count

          summary.append("## ğŸ“Š Resumen Ejecutivo\n\n")
          summary.append("| ğŸ”§ Ecosistemas | ğŸ·ï¸ Labels VÃ¡lidos | âš ï¸ Labels Faltantes | ğŸ”„ PRs Activos |\n")
          summary.append("|:--------------:|:-----------------:|:-------------------:|:--------------:|\n")
          summary.append(f"| **{total_ecosystems}** | **{valid_count}** | **{missing_count}** | **{prs_count}** |\n\n")

          # Tabla de ecosistemas
          summary.append("<details open>\n")
          summary.append("<summary><h2>ğŸ“¦ Ecosistemas Configurados</h2></summary>\n\n")
          summary.append("<table>\n")
          summary.append("<colgroup>\n")
          summary.append("<col style='width:12%'>\n")
          summary.append("<col style='width:12%'>\n")
          summary.append("<col style='width:10%'>\n")
          summary.append("<col style='width:8%'>\n")
          summary.append("<col style='width:28%'>\n")
          summary.append("<col style='width:30%'>\n")
          summary.append("</colgroup>\n")
          summary.append("<thead>\n")
          summary.append("<tr>\n")
          summary.append("<th>Ecosistema</th>\n")
          summary.append("<th>Directorio</th>\n")
          summary.append("<th>Prefijo</th>\n")
          summary.append("<th>PR Limit</th>\n")
          summary.append("<th>Labels VÃ¡lidos</th>\n")
          summary.append("<th>Labels Faltantes</th>\n")
          summary.append("</tr>\n")
          summary.append("</thead>\n")
          summary.append("<tbody>\n")

          for eco in ecosystems:
              eco_key = f"{eco['ecosystem']}|{eco['directory']}"
              
              valid_labels = valid_by_ecosystem.get(eco_key, [])
              missing_labels = missing_by_ecosystem.get(eco_key, [])

              valid_badges = []
              for label in valid_labels:
                  label_info = existing_labels.get(label.lower(), {})
                  color = label_info.get('color', '0366d6')
                  valid_badges.append(
                      f"<img src='https://img.shields.io/badge/{label.replace('-', '--')}-{color}?style=flat-square' alt='{label}' style='margin:2px'>"
                  )

              missing_badges = [
                  f'<code style="white-space:nowrap">{label}</code>' 
                  for label in missing_labels
              ]

              summary.append("<tr>\n")
              summary.append(f"<td><code>{eco['ecosystem']}</code></td>\n")
              summary.append(f"<td><code>{eco['directory']}</code></td>\n")
              summary.append(f"<td><code>{eco.get('prefix', '-')}</code></td>\n")
              summary.append(f"<td>{eco.get('pr_limit', '${{ inputs.pr_limit }}')}</td>\n")
              summary.append(f"<td>{' '.join(valid_badges) if valid_badges else 'â–'}</td>\n")
              summary.append(f"<td>{' '.join(missing_badges) if missing_badges else 'âœ…'}</td>\n")
              summary.append("</tr>\n")

          summary.append("</tbody>\n")
          summary.append("</table>\n\n")

          if missing_count > 0:
              labels_url = f"{server_url}/{repo}/labels"
              summary.append(f"> âš ï¸ **AcciÃ³n Recomendada:** Algunos labels no existen. ")
              summary.append(f"<a href='{labels_url}'>ğŸ”§ <b>Crear labels faltantes</b></a> o ajustar la configuraciÃ³n.\n\n")

          summary.append("</details>\n\n")

          # PRs de Dependabot
          if prs_data and len(prs_data) > 0:
              summary.append("<details>\n")
              summary.append(f"<summary><h2>ğŸ”„ Pull Requests de Dependabot ({min(prs_count, 15)})</h2></summary>\n\n")

              summary.append("<table>\n")
              summary.append("<thead>\n")
              summary.append("<tr>\n")
              summary.append("<th>PR</th>\n")
              summary.append("<th>TÃ­tulo</th>\n")
              summary.append("<th>Labels</th>\n")
              summary.append("<th>Creado</th>\n")
              summary.append("</tr>\n")
              summary.append("</thead>\n")
              summary.append("<tbody>\n")

              for pr in prs_data[:15]:
                  pr_number = pr.get('number', 'N/A')
                  pr_url = pr.get('url', '#')
                  pr_title = pr.get('title', 'Sin tÃ­tulo')
                  pr_labels = ', '.join([l.get('name', '') for l in pr.get('labels', [])])
                  pr_created = pr.get('createdAt', '')
                  
                  try:
                      pr_date = datetime.fromisoformat(pr_created.replace('Z', '+00:00')).strftime('%Y-%m-%d')
                  except:
                      pr_date = 'N/A'

                  summary.append("<tr>\n")
                  summary.append(f"<td><a href='{pr_url}'><b>#{pr_number}</b></a></td>\n")
                  summary.append(f"<td>{pr_title}</td>\n")
                  summary.append(f"<td>{pr_labels if pr_labels else 'â–'}</td>\n")
                  summary.append(f"<td>{pr_date}</td>\n")
                  summary.append("</tr>\n")

              summary.append("</tbody>\n")
              summary.append("</table>\n\n")

              if prs_count > 15:
                  prs_url = f"{server_url}/{repo}/pulls?q=is%3Apr+is%3Aopen+author%3Adependabot"
                  summary.append(f"> <a href='{prs_url}'>ğŸ“‹ <b>Ver todos los PRs ({prs_count})</b></a>\n\n")

              summary.append("</details>\n\n")
          else:
              summary.append("<details>\n")
              summary.append("<summary><h2>ğŸ”„ Pull Requests de Dependabot</h2></summary>\n\n")
              summary.append("> â„¹ï¸ No hay PRs activos de Dependabot en este momento.\n\n")
              summary.append("</details>\n\n")

          issue_url = os.getenv('ISSUE_URL','')
          if issue_url:
              summary.append(f"> ğŸ§¾ <b>Issue de reporte:</b> <a href='{issue_url}'>{issue_url}</a>\n\n")

          # Enlaces Ãºtiles
          summary.append("<details>\n")
          summary.append("<summary><h2>ğŸ”— Enlaces Ãštiles</h2></summary>\n\n")

          config_url = f"{server_url}/{repo}/blob/main/.github/dependabot.yml"
          summary.append(f"- ğŸ“ <a href='{config_url}'><b>Ver ConfiguraciÃ³n</b></a> â€” Archivo dependabot.yml generado\n")

          security_url = f"{server_url}/{repo}/settings/security_analysis"
          summary.append(f"- ğŸ›¡ï¸ <a href='{security_url}'><b>Security Settings</b></a> â€” Configurar anÃ¡lisis de seguridad\n")

          insights_url = f"{server_url}/{repo}/network/dependencies"
          summary.append(f"- ğŸ“Š <a href='{insights_url}'><b>Dependency Graph</b></a> â€” Visualizar dependencias\n")

          labels_url = f"{server_url}/{repo}/labels"
          summary.append(f"- ğŸ·ï¸ <a href='{labels_url}'><b>Gestionar Labels</b></a> â€” Crear o editar labels\n")

          prs_url = f"{server_url}/{repo}/pulls?q=is%3Apr+author%3Adependabot"
          summary.append(f"- ğŸ”„ <a href='{prs_url}'><b>PRs de Dependabot</b></a> â€” Ver Pull Requests activos\n")

          advisories_url = f"{server_url}/{repo}/security/dependabot"
          summary.append(f"- ğŸš¨ <a href='{advisories_url}'><b>Security Alerts</b></a> â€” Revisar alertas de seguridad\n\n")

          summary.append("</details>\n\n")

          # InformaciÃ³n del workflow
          summary.append("<details>\n")
          summary.append("<summary><b>ğŸ“š Sobre el Workflow Reusable</b></summary>\n\n")

          summary.append("#### âœ… CaracterÃ­sticas\n\n")
          summary.append("- ğŸ” ValidaciÃ³n automÃ¡tica de labels\n")
          summary.append("- ğŸ›¡ï¸ Filtrado automÃ¡tico de labels invÃ¡lidos\n")
          summary.append("- ğŸ“Š Summary con diseÃ±o consolidado y responsive\n")
          summary.append("- ğŸ·ï¸ Badges con colores del repositorio\n")
          summary.append("- ğŸ”— Enlaces directos a recursos\n")
          summary.append("- ğŸ”„ DetecciÃ³n de PRs existentes\n")
          summary.append("- ğŸ“ ConfiguraciÃ³n personalizable\n")
          summary.append("- ğŸ¯ Rama objetivo configurable\n\n")

          summary.append("#### ğŸ”® Mejoras Futuras\n\n")
          summary.append("- ğŸ”” Notificaciones a Slack/Discord\n")
          summary.append("- ğŸ“ˆ Matriz de compatibilidad\n")
          summary.append("- ğŸ›¡ï¸ IntegraciÃ³n con Security Advisories\n")
          summary.append("- ğŸ“Š Dashboard centralizado\n")
          summary.append("- ğŸ” AnÃ¡lisis predictivo de impacto\n\n")

          summary.append("</details>\n\n")

          # Footer
          timestamp = datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M UTC')
          workflow_url = f"{server_url}/jersonmartinez/reusable-workflows"
          summary.append(f"<sub>ğŸ¤– Generado por <a href='{workflow_url}'><b>Reusable Workflows</b></a> â€¢ {timestamp}</sub>\n")

          # Escribir summary
          with open(os.environ['GITHUB_STEP_SUMMARY'], 'w') as f:
              f.write(''.join(summary))

          print("âœ… Summary generado correctamente")
          print(f"ğŸ“Š PRs detectados: {prs_count}")
          print(f"ğŸ“¦ Ecosistemas: {len(ecosystems)}")
          print(f"âœ… Labels vÃ¡lidos: {valid_count}")
          print(f"âš ï¸ Labels omitidos: {missing_count}")
          SCRIPT_EOF

          python3 /tmp/generate_summary.py

      - name: ğŸ’¾ Subir artifact de depuraciÃ³n
        if: ${{ inputs.upload_debug_artifact }}
        uses: actions/upload-artifact@v4
        with:
          name: dependabot-report-debug
          path: docs/output.txt
