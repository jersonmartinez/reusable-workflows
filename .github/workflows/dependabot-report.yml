name: Setup Dependabot

on:
  workflow_call:
    inputs:

      create_issue:
        required: false
        type: boolean
        default: true

      issue_title:
        required: false
        type: string
        default: 'Reporte Dependabot: ${date}'

      issue_labels:
        required: false
        type: string
        default: 'dependabot-report'

      close_dependabot_prs:
        required: false
        type: boolean
        default: true

      wait_minutes:
        required: false
        type: number
        default: 5

      create_missing_labels:
        required: false
        type: boolean
        default: false

      create_issue_if_empty:
        required: false
        type: boolean
        default: true

      upload_debug_artifact:
        required: false
        type: boolean
        default: true

      trigger_dependabot_now:
        required: false
        type: boolean
        default: false

      dependabot_config_path:
        required: false
        type: string
        default: '.github/dependabot.yml'

      dependabot_logins:
        required: false
        type: string
        default: 'dependabot,dependabot[bot],app/dependabot'

      poll_interval_seconds:
        required: false
        type: number
        default: 30

      dry_run_close:
        required: false
        type: boolean
        default: false

      skip_close_labels:
        required: false
        type: string
        default: ''

      max_prs_in_summary:
        required: false
        type: number
        default: 30

      generate_pdf_report:
        required: false
        type: boolean
        default: false

      pdf_report_name:
        required: false
        type: string
        default: 'dependabot-report.pdf'

      generate_html_report:
        required: false
        type: boolean
        default: true

      html_report_name:
        required: false
        type: string
        default: 'dependabot-report.html'
      fast_summary:
        required: false
        type: boolean
        default: true

      prs_state:
        required: false
        type: string
        default: 'all'

      company_name:
        required: false
        type: string
        default: 'PRB'


      logo_url:
        required: false
        type: string
        default: 'https://extranet.prb.com.mx/Prb1.2/images/logos/logo_PRB.svg'

jobs:
  configure:
    name: Configuring
    runs-on: ubuntu-latest
    timeout-minutes: 45
    concurrency:
      group: dependabot-report
      cancel-in-progress: true
    outputs:
      prs_data: ${{ steps.detect_prs.outputs.prs_data }}
      issue_url: ${{ steps.create_issue.outputs.issue_url }}
      alerts_data: ${{ steps.collect_alerts.outputs.alerts_data }}

    steps:
      - name: ðŸš€ Checkout Repository
        uses: actions/checkout@v4

      - name: ðŸ†” Determine Workflow Ref
        id: workflow_ref
        run: |
          WORKFLOW_REF="${{ github.workflow_ref }}"
          if [ -z "$WORKFLOW_REF" ]; then
            echo "ref=${{ github.ref }}" >> $GITHUB_OUTPUT
            echo "repo=${{ github.repository }}" >> $GITHUB_OUTPUT
          else
            REF=$(echo "$WORKFLOW_REF" | cut -d'@' -f2)
            REPO=$(echo "$WORKFLOW_REF" | cut -d'/' -f1,2)
            echo "ref=$REF" >> $GITHUB_OUTPUT
            echo "repo=$REPO" >> $GITHUB_OUTPUT
          fi

      - name: ðŸ“¥ Checkout Scripts
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.workflow_ref.outputs.repo }}
          ref: ${{ steps.workflow_ref.outputs.ref }}
          path: .reusable-scripts
          sparse-checkout: scripts

      - name: ðŸ•’ Marcar inicio
        if: false
        run: echo "skip"

      - name: ðŸ§ª Preparar logs de depuraciÃ³n
        run: |
          mkdir -p docs
          printf "[START] Dependabot report debug at %s\n" "$(date -u +'%Y-%m-%d %H:%M:%SZ')" > docs/output.txt

      - name: âš¡ Trigger Dependabot (opcional)
        if: ${{ inputs.trigger_dependabot_now }}
        env:
          GH_TOKEN: ${{ github.token }}
          CFG_PATH: ${{ inputs.dependabot_config_path }}
        run: |
          set -e
          if [ ! -f "$CFG_PATH" ]; then
            echo "::warning::No existe $CFG_PATH. No se puede forzar ejecuciÃ³n"
            exit 0
          fi
          TS=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          echo "# trigger: $TS" >> "$CFG_PATH"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "$CFG_PATH"
          if git diff --cached --quiet; then
            echo "Sin cambios en $CFG_PATH"
          else
            git commit -m "chore(dependabot): trigger run at $TS"
            git push || echo "::warning::No se pudo pushear cambios (verificar permisos)"
            echo "Triggered Dependabot via config change at $TS" >> docs/output.txt
          fi

      - name: ðŸ” Validate Labels
        id: validate_labels
        if: false
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          cat > /tmp/validate_labels.py << 'SCRIPT_EOF'
          import json, os, subprocess, sys
          from collections import defaultdict

          repo = os.getenv('GITHUB_REPOSITORY')

          try:
              result = subprocess.run(
                  ['gh', 'label', 'list', '--repo', repo, '--json', 'name,color,description', '--limit', '1000'],
                  capture_output=True, text=True, check=True
              )
              labels_data = json.loads(result.stdout)
              existing_labels = {label['name'].lower(): label for label in labels_data}
          except Exception as e:
              print(f"::error::No se pudieron obtener los labels: {e}")
              existing_labels = {}

          try:
              ecosystems = json.loads('''${{ inputs.ecosystems }}''')
          except json.JSONDecodeError as e:
              print(f"::error::Error al parsear ecosistemas: {e}")
              sys.exit(1)

          missing_by_ecosystem = defaultdict(list)
          valid_by_ecosystem = defaultdict(list)
          filtered_ecosystems = []
          all_missing = set()

          for eco in ecosystems:
              labels = [l.strip() for l in eco.get('labels', '').split(',') if l.strip()]
              valid_labels = []
              
              for label in labels:
                  if label.lower() in existing_labels:
                      valid_by_ecosystem[f"{eco['ecosystem']}|{eco['directory']}"].append(label)
                      valid_labels.append(label)
                  else:
                      missing_by_ecosystem[f"{eco['ecosystem']}|{eco['directory']}"].append(label)
                      all_missing.add(label)

              # Crear ecosistema filtrado con SOLO labels vÃ¡lidos
              filtered_eco = eco.copy()
              filtered_eco['labels'] = ','.join(valid_labels)
              filtered_ecosystems.append(filtered_eco)

          # Generar outputs
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"missing_labels={','.join(sorted(all_missing))}\n")
              f.write(f"missing_count={len(all_missing)}\n")
              f.write(f"valid_count={sum(len(v) for v in valid_by_ecosystem.values())}\n")
              f.write(f"has_missing={'true' if all_missing else 'false'}\n")
              
              # Exportar ecosistemas filtrados
              filtered_json = json.dumps(filtered_ecosystems)
              f.write(f"filtered_ecosystems<<EOF\n")
              f.write(f"{filtered_json}\n")
              f.write(f"EOF\n")

          # Guardar datos para el summary
          with open('/tmp/validation_data.json', 'w') as f:
              json.dump({
                  'missing_by_ecosystem': dict(missing_by_ecosystem),
                  'valid_by_ecosystem': dict(valid_by_ecosystem),
                  'existing_labels': existing_labels
              }, f)

          if all_missing:
              print(f"::warning title=Labels Faltantes::Se encontraron {len(all_missing)} labels sin configurar. SerÃ¡n omitidos del archivo generado.")
              for label in sorted(all_missing):
                  print(f"  âš ï¸ {label}")
          else:
              print("::notice title=ValidaciÃ³n Exitosa::Todos los labels estÃ¡n configurados correctamente")
          
          print(f"\nðŸ“Š Resumen:")
          print(f"  âœ… Labels vÃ¡lidos: {sum(len(v) for v in valid_by_ecosystem.values())}")
          print(f"  âš ï¸ Labels faltantes: {len(all_missing)}")
          print(f"  ðŸ“¦ Ecosistemas: {len(ecosystems)}")
          SCRIPT_EOF

          python3 /tmp/validate_labels.py

      - name: ðŸ·ï¸ Crear labels faltantes
        if: false
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          MISSING="${{ steps.validate_labels.outputs.missing_labels }}"
          REPO="$GITHUB_REPOSITORY"
          IFS=',' read -ra LABELS <<< "$MISSING"
          for l in "${LABELS[@]}"; do
            [ -z "$l" ] && continue
            gh label create "$l" --repo "$REPO" --color 0366d6 --description "Auto-creado para Dependabot" || true
            echo "Creado label: $l"
          done

      - name: ðŸ·ï¸ Crear labels del Issue faltantes
        if: ${{ inputs.issue_labels != '' && inputs.create_missing_labels }}
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_LABELS: ${{ inputs.issue_labels }}
        run: |
          REPO="$GITHUB_REPOSITORY"
          EXISTING=$(gh label list --repo "$REPO" --json name --jq '.[].name')
          declare -A MAP
          for n in $EXISTING; do MAP[$n]=1; done
          IFS=',' read -ra LBS <<< "$ISSUE_LABELS"
          for l in "${LBS[@]}"; do
            NAME=$(echo "$l" | xargs)
            [ -z "$NAME" ] && continue
            if [ -z "${MAP[$NAME]}" ]; then
              gh label create "$NAME" --repo "$REPO" --color 6f42c1 --description "Auto-creado para reporte" || true
              echo "Creado label de Issue: $NAME"
            fi
          done

      - name: ðŸ“ Generate Dependabot Config
        if: false
        env:
          FILTERED_ECOSYSTEMS: ${{ steps.validate_labels.outputs.filtered_ecosystems }}
        run: |
          cat > /tmp/generate_config.py << 'SCRIPT_EOF'
          import json, os, sys

          try:
              ecosystems = json.loads(os.getenv('FILTERED_ECOSYSTEMS', '[]'))
          except json.JSONDecodeError as e:
              print(f"::error::JSON invÃ¡lido: {e}")
              sys.exit(1)

          if not ecosystems:
              print("::error::No hay ecosistemas para configurar")
              sys.exit(1)

          schedule = '${{ inputs.schedule }}'
          pr_limit = ${{ inputs.pr_limit }}
          target_branch = '${{ inputs.target_branch }}'

          config = {'version': 2, 'updates': []}

          for eco in ecosystems:
              update = {
                  'package-ecosystem': eco['ecosystem'],
                  'directory': eco['directory'],
                  'schedule': {'interval': schedule},
                  'open-pull-requests-limit': eco.get('pr_limit', pr_limit)
              }

              if target_branch:
                  update['target-branch'] = target_branch

              # Los labels ya estÃ¡n filtrados (solo vÃ¡lidos)
              labels = [l.strip() for l in eco.get('labels', '').split(',') if l.strip()]
              if labels:
                  update['labels'] = labels

              prefix = eco.get('prefix', '').strip()
              if prefix:
                  update['commit-message'] = {'prefix': prefix}

              config['updates'].append(update)

          import yaml
          os.makedirs('.github', exist_ok=True)

          with open('.github/dependabot.yml', 'w') as f:
            yaml.dump(config, f, sort_keys=False, default_flow_style=False, indent=2)

          print("âœ… ConfiguraciÃ³n generada exitosamente (solo con labels vÃ¡lidos)")

          with open('.github/dependabot.yml', 'r') as f:
              content = f.read()
              print("\nðŸ“„ Contenido generado:")
              print(content)
          SCRIPT_EOF

          python3 /tmp/generate_config.py

      - name: ðŸ’¾ Commit Changes
        id: commit
        if: false
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          if git diff --quiet .github/dependabot.yml; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "ðŸ“Œ Sin cambios - La configuraciÃ³n estÃ¡ actualizada"
          else
            git add .github/dependabot.yml
            git commit -m "chore: update dependabot configuration"
            git push
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "commit_sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
            echo "âœ… Cambios commiteados y pusheados"
          fi

      - name: ðŸ”„ Detect Dependabot PRs
        id: detect_prs
        env:
          GH_TOKEN: ${{ github.token }}
          WAIT_MINUTES: ${{ inputs.wait_minutes }}
          POLL_INTERVAL: ${{ inputs.poll_interval_seconds }}
          DEP_LOGINS: ${{ inputs.dependabot_logins }}
          PRS_STATE: ${{ inputs.prs_state }}
          TRIGGER_DEPENDABOT_NOW: ${{ inputs.trigger_dependabot_now }}
        run: python3 .reusable-scripts/scripts/detect_prs.py

      - name: ðŸ“¦ Recoger alertas de Dependabot
        id: collect_alerts
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
        run: |
          python3 - << 'PY'
          import os, json, subprocess
          repo = os.getenv('REPO','')
          alerts = []
          try:
              r = subprocess.run(['gh','api', f'repos/{repo}/dependabot/alerts', '-f', 'state=open', '-f', 'per_page=100'], capture_output=True, text=True)
              if r.returncode == 0 and r.stdout.strip():
                  data = json.loads(r.stdout)
                  if isinstance(data, list):
                      alerts = data
          except Exception:
              alerts = []
          with open(os.environ['GITHUB_OUTPUT'],'a') as f:
              f.write('alerts_data<<EOF\n')
              f.write(json.dumps(alerts))
              f.write('\nEOF\n')
          PY

      - name: ðŸ’¾ Guardar PRs detectados
        env:
          PRS_DATA: ${{ steps.detect_prs.outputs.prs_data }}
        run: |
          mkdir -p docs
          echo "$PRS_DATA" > docs/prs.json

      - name: ðŸ§¾ Crear Issue de Reporte
        id: create_issue
        if: ${{ inputs.create_issue && (steps.detect_prs.outputs.prs_count != '0' || inputs.create_issue_if_empty) }}
        env:
          GH_TOKEN: ${{ github.token }}
          PRS_DATA: ${{ steps.detect_prs.outputs.prs_data }}
          ISSUE_TITLE_TPL: ${{ inputs.issue_title }}
          ISSUE_LABELS: ${{ inputs.issue_labels }}
          RUN_ID: ${{ github.run_id }}
          SERVER_URL: ${{ github.server_url }}
        run: python3 .reusable-scripts/scripts/create_issue.py

      - name: ðŸ“„ Generar PDF del reporte
        id: generate_pdf
        if: false
        env:
          PRS_DATA: ${{ steps.detect_prs.outputs.prs_data }}
          PDF_PATH: docs/${{ inputs.pdf_report_name }}
          REPO: ${{ github.repository }}
          GH_TOKEN: ${{ github.token }}
          ISSUE_URL: ${{ steps.create_issue.outputs.issue_url }}
        run: |
          sudo apt-get update -y || true
          sudo apt-get install -y libcairo2 libcairo2-dev libpango1.0-dev libgdk-pixbuf2.0-dev pkg-config || true
          python3 -m pip install --user reportlab || true
          python3 -m pip install --user svglib lxml cssselect2 tinycss2 || true
          export PYTHONPATH="$(python3 -c 'import site; print(site.getusersitepackages())')${PYTHONPATH:+:$PYTHONPATH}"
          python3 scripts/generate_pdf.py

      - name: ðŸ“Š Generate Summary
        env:
          PRS_DATA: ${{ steps.detect_prs.outputs.prs_data }}
          PRS_COUNT: ${{ steps.detect_prs.outputs.prs_count }}
          ISSUE_URL: ${{ steps.create_issue.outputs.issue_url }}
          TRIGGER_DEPENDABOT_NOW: ${{ inputs.trigger_dependabot_now }}
          MAX_SUMMARY: ${{ inputs.max_prs_in_summary }}
          FAST_SUMMARY: ${{ inputs.fast_summary }}
          COMPANY_NAME: ${{ inputs.company_name }}
          GH_TOKEN: ${{ github.token }}
        run: python3 .reusable-scripts/scripts/generate_summary.py

      - name: ðŸ’¾ Subir artifact de depuraciÃ³n
        if: ${{ inputs.upload_debug_artifact }}
        uses: actions/upload-artifact@v4
        with:
          name: dependabot-report-debug
          path: docs/output.txt

  report_html:
    name: Generate HTML report
    runs-on: ubuntu-latest
    needs: [configure]
    if: ${{ inputs.generate_html_report }}
    steps:
      - name: ðŸš€ Checkout Repository
        uses: actions/checkout@v4
      - name: ðŸ§¾ Generar HTML del reporte (modular)
        uses: ./.github/actions/dependabot-html-report
        with:
          prs_data: ${{ needs.configure.outputs.prs_data }}
          alerts_data: ${{ needs.configure.outputs.alerts_data }}
          output_path: docs/${{ inputs.html_report_name }}
          issue_url: ${{ needs.configure.outputs.issue_url }}
          company_name: ${{ inputs.company_name }}
          logo_url: ${{ inputs.logo_url }}
      - name: â™»ï¸ Guardar HTML en cache
        uses: actions/cache/save@v4
        with:
          path: docs/${{ inputs.html_report_name }}
          key: dep-report-${{ github.run_id }}-html

      - name: ðŸ“¤ Subir HTML como artefacto (sin PDF)
        if: ${{ inputs.generate_html_report && !inputs.generate_pdf_report }}
        uses: actions/upload-artifact@v4
        with:
          name: dependabot-reportes
          path: docs/${{ inputs.html_report_name }}
          if-no-files-found: warn

  report_pdf:
    name: Generate PDF report
    runs-on: ubuntu-latest
    needs: [configure]
    if: ${{ inputs.generate_pdf_report }}
    outputs:
      pdf_created: ${{ steps.generate_pdf.outputs.created }}
    steps:
      - name: ðŸš€ Checkout Repository
        uses: actions/checkout@v4

      - name: ðŸ†” Determine Workflow Ref
        id: workflow_ref
        run: |
          WORKFLOW_REF="${{ github.workflow_ref }}"
          if [ -z "$WORKFLOW_REF" ]; then
            echo "ref=${{ github.ref }}" >> $GITHUB_OUTPUT
            echo "repo=${{ github.repository }}" >> $GITHUB_OUTPUT
          else
            REF=$(echo "$WORKFLOW_REF" | cut -d'@' -f2)
            REPO=$(echo "$WORKFLOW_REF" | cut -d'/' -f1,2)
            echo "ref=$REF" >> $GITHUB_OUTPUT
            echo "repo=$REPO" >> $GITHUB_OUTPUT
          fi

      - name: ðŸ“¥ Checkout Scripts
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.workflow_ref.outputs.repo }}
          ref: ${{ steps.workflow_ref.outputs.ref }}
          path: .reusable-scripts
          sparse-checkout: scripts

      - name: ðŸ“„ Generar PDF del reporte (parallel)
        id: generate_pdf
        env:
          PRS_DATA: ${{ needs.configure.outputs.prs_data }}
          PDF_PATH: docs/${{ inputs.pdf_report_name }}
          REPO: ${{ github.repository }}
          GH_TOKEN: ${{ github.token }}
          ISSUE_URL: ${{ needs.configure.outputs.issue_url }}
        run: |
          sudo apt-get update -y || true
          sudo apt-get install -y libcairo2 libcairo2-dev libpango1.0-dev libgdk-pixbuf2.0-dev pkg-config || true
          python3 -m pip install --user reportlab || true
          python3 -m pip install --user svglib lxml cssselect2 tinycss2 || true
          export PYTHONPATH="$(python3 -c 'import site; print(site.getusersitepackages())')${PYTHONPATH:+:$PYTHONPATH}"
          python3 .reusable-scripts/scripts/generate_pdf.py
